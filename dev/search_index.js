var documenterSearchIndex = {"docs":
[{"location":"examples/disk_kerr/#Thin-disk-around-a-Kerr-black-hole","page":"Thin disk around a Kerr black hole","title":"Thin disk around a Kerr black hole","text":"","category":"section"},{"location":"examples/disk_kerr/","page":"Thin disk around a Kerr black hole","title":"Thin disk around a Kerr black hole","text":"using Skylight\nusing CairoMakie\n\nspacetime = KerrSpacetimeBoyerLindquistCoordinates(M = 1.0, a = 0.9)\n\ncamera = ImagePlane(distance = 500.0,\n    observer_inclination_in_degrees = 90,\n    horizontal_side = 23.0,\n    vertical_side = 23.0,\n    horizontal_number_of_pixels = 100,\n    vertical_number_of_pixels = 100)\n\nmodel = NovikovThorneDisk(inner_radius = isco_radius(spacetime), outer_radius = 18.0)\n\nconfigurations = VacuumOTEConfigurations(spacetime = spacetime,\n    camera = camera,\n    radiative_model = model,\n    unit_mass_in_solar_masses = 1.0)\n\ninitial_data = initialize(configurations)\n\ncb, cbp = callback_setup(configurations; rhorizon_bound = 2e-1) #... or, define your own cb and cbp\n\nrun = integrate(initial_data,\n    configurations,\n    cb,\n    cbp;\n    method = VCABM(),\n    reltol = 1e-13,\n    abstol = 1e-21)\n\noutput_data = run.output_data\n\nIobs = observed_bolometric_intensities(initial_data, output_data, configurations)\n\nxs, ys = axes_ranges(camera)\n\nzs = grid_view(Iobs, configurations)\n\nfig = Figure(font = \"CMU Serif\")\nax = Axis(fig[1, 1],\n    xlabel = L\"\\alpha\",\n    ylabel = L\"\\beta\",\n    ylabelsize = 26,\n    xlabelsize = 26)\nhmap = heatmap!(xs, ys, zs / maximum(zs); colormap = :gist_heat, interpolate = true)\nColorbar(fig[:, end + 1],\n    hmap,\n    label = L\"I\",\n    labelsize = 26,\n    width = 15,\n    ticksize = 18,\n    tickalign = 1)\ncolsize!(fig.layout, 1, Aspect(1, 1.0))\ncolgap!(fig.layout, 7)\nCairoMakie.save(\"plot.png\", fig)","category":"page"},{"location":"spacetimes/othertypes/#Other-types","page":"Other types","title":"Other types","text":"","category":"section"},{"location":"spacetimes/othertypes/","page":"Other types","title":"Other types","text":"Modules = [Skylight]\nPages = [\"spacetimes/types.jl\"]\nFilter = t -> typeof(t) === DataType ","category":"page"},{"location":"spacetimes/othertypes/#Skylight.AbstractBlackHoleSpacetime","page":"Other types","title":"Skylight.AbstractBlackHoleSpacetime","text":"AbstractBlackHoleSpacetime <: AbstractSpacetime\n\nSupertype for representing spacetimes containing black holes. \n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.AbstractChristoffelCache","page":"Other types","title":"Skylight.AbstractChristoffelCache","text":"AbstractSpacetimeCache\n\nAbstract type for cache objects to be used as temporary storage in Christoffel symbol calculations.\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.AbstractCoordinatesTopology","page":"Other types","title":"Skylight.AbstractCoordinatesTopology","text":"AbstractCoordinatesTopology\n\nAbstract type for representing the topology of the coordinates of a spacetime.\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.AbstractRegularCompactObjectSpacetime","page":"Other types","title":"Skylight.AbstractRegularCompactObjectSpacetime","text":"AbstractRegularCompactObjectSpacetime <: AbstractSpacetime\n\nSupertype for representing spacetimes containing compact objects without horizons like boson stars. \n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.AbstractRotationSense","page":"Other types","title":"Skylight.AbstractRotationSense","text":"AbstractRotationSense\n\nAbstract type for representing the rotation sense of a circular orbit in a spacetime.\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.AbstractSpacetime","page":"Other types","title":"Skylight.AbstractSpacetime","text":"AbstractSpacetime\n\nSupertype for representing the geometrical structure of spacetime. Specific implementations of spacetime, such as black holes and regular compact objects, are subtypes of this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.AbstractSpacetimeCache","page":"Other types","title":"Skylight.AbstractSpacetimeCache","text":"AbstractSpacetimeCache\n\nAbstract type for caching spacetime-related computations. This can be used as scratch memory in calculations involving the spacetime.\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.CartesianTopology","page":"Other types","title":"Skylight.CartesianTopology","text":"CartesianTopology <: AbstractCoordinatesTopology\n\nCartesian coordinates topology.\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.ProgradeRotation","page":"Other types","title":"Skylight.ProgradeRotation","text":"ProgradeRotation <: AbstractRotationSense\n\nPrograde rotation sense for a circular orbit in a spacetime.\n\nConstructor\n\nProgradeRotation()\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.RetrogradeRotation","page":"Other types","title":"Skylight.RetrogradeRotation","text":"RetrogradeRotation <: AbstractRotationSense\n\nRetrograde rotation sense for a circular orbit in a spacetime.\n\nConstructor\n\nRetrogradeRotation()\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.SphericalTopology","page":"Other types","title":"Skylight.SphericalTopology","text":"SphericalTopology <: AbstractCoordinatesTopology\n\nSpherical coordinates topology.\n\n\n\n\n\n","category":"type"},{"location":"radiativemodels/radiativeprocesses/#Radiative-processes","page":"Radiative processes","title":"Radiative processes","text":"","category":"section"},{"location":"gettingstarted/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"To get started, you will need a spacetime, a radiative model, and a camera. For example, to instantiate a Kerr spacetime in Kerr-Schild coordinates with mass M=1 and spin aM=05, ","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"using Skylight\n\nspacetime = KerrSpacetimeBoyerLindquistCoordinates(M=1.0,a=0.5)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"A catalogue of currently available spacetimes is at Catalogue of spacetimes. Next, instantiate a radiative model as, e.g.","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"disk = NovikovThorneDisk(inner_radius=isco_radius(spacetime, ProgradeRotation()), outer_radius = 15.0)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"See the currently available radiative models at Catalogue of radiative models. Then, you can construct a camera as ","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"camera = PinholeCamera(position = [0.0, 500, π/2-π/20, 0.0],\n                        horizontal_aperture_in_degrees = rad2deg(315/500),\n                        vertical_aperture_in_degrees = rad2deg(315/500),\n                        horizontal_number_of_pixels = 600,\n                        vertical_number_of_pixels = 600)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"See Pinhole camera for an explanation of this camera setup. Finally, gather these objects into a configurations object. This is a vacuum transport problem, so use","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"configurations = VacuumOTEConfigurations(spacetime=spacetime,\n                                        radiative_model=disk,\n                                        camera = camera,\n                                        unit_mass_in_solar_masses = 1.0)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"where unit_mass_in_solar_masses is the unit mass in solar masses which determines fully the problem units together with c=G=1, and OTE stands for the observer-to-emitter scheme. This paticular configurations type will get the specialized methods for transport in vacuum. For more general non vacuum problems, use","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"configurations = NonVacuumOTEConfigurations(spacetime = spacetime,\n    camera = camera,\n    radiative_model = model,\n    unit_mass_in_solar_masses = 1.0,\n    observation_energies = exp10.(range(-10, stop = -5.5, length = 20)))","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"Then, create the initial data as","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"initial_data = initialize(configurations)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"The initial data is a matrix that has the initial conditions for each ray as columns, where the first four components are the spacetime coordinates, and the last four are the components of the initial four-momentum in the coordinate frame. ","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"Before running the ray-tracing, you need to specify a callback to be called at each step of the equations integration. For the default callback, use","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"cb, cbp = callback_setup(configurations)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"You can also define your own callbacks. For more details, see Callbacks and Event Handling. Finally, you can integrate the equations with","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"sim = integrate(initial_data,\n    configurations,\n    cb,\n    cbp;\n    method = VCABM(),\n    reltol = 1e-8,\n    abstol = 1e-8)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"You can choose any of the available solver methods from DifferentalEquations.jl.","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"The output data can be obtained as","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"output_data = sim.output_data","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"This matrix contains the final coordinates and momenta of each ray, with the same structure as the initial data. Finally, you can compute, for instance, the observed bolometric intensity of the radiation field and produce an image as","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"using CairoMakie\n\nIobs = observed_bolometric_intensities(initial_data, output_data, configurations)\n\nxs, ys = axes_ranges(camera)\nzs = grid_view(Iobs, configurations)\n\nfig = Figure(font = \"CMU Serif\")\nax = Axis(fig[1, 1],\n    xlabel = L\"\\alpha\",\n    ylabel = L\"\\beta\",\n    ylabelsize = 26,\n    xlabelsize = 26)\nhmap = heatmap!(xs, ys, zs; colormap = :gist_heat, interpolate = true)\nColorbar(fig[:, end + 1],\n    hmap,\n    label = L\"I\",\n    labelsize = 26,\n    width = 15,\n    ticksize = 18,\n    tickalign = 1)\ncolsize!(fig.layout, 1, Aspect(1, 1.0))\ncolgap!(fig.layout, 7)","category":"page"},{"location":"configurations/configurations/#Configurations","page":"Configurations","title":"Configurations","text":"","category":"section"},{"location":"miscellanea/utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"publications/#Publications","page":"Publications","title":"Publications","text":"","category":"section"},{"location":"publications/","page":"Publications","title":"Publications","text":"This software has been utilized in the following publications:","category":"page"},{"location":"publications/","page":"Publications","title":"Publications","text":"Neto, M. R., Perez, D., & Pelle, J. (2023). The shadow of charged traversable wormholes. International Journal of Modern Physics D, 32(02), 2250137.\nCarrasco, F., Pelle, J., Reula, O., Viganò, D., & Palenzuela, C. (2023). Relativistic force-free models of the thermal X-ray emission in millisecond pulsars observed by NICER. Monthly Notices of the Royal Astronomical Society, 520(2), 3151-3163.\nPelle, J., Reula, O., Carrasco, F., & Bederian, C. (2022). Skylight: a new code for general-relativistic ray-tracing and radiative transfer in arbitrary space–times. Monthly Notices of the Royal Astronomical Society, 515(1), 1316-1327.","category":"page"},{"location":"examples/frkerr/#Thin-accretion-disk-arond-f(R)-Kerr-black-hole","page":"f(R)-Kerr black hole","title":"Thin accretion disk arond f(R)-Kerr black hole","text":"","category":"section"},{"location":"examples/frkerr/","page":"f(R)-Kerr black hole","title":"f(R)-Kerr black hole","text":"using Skylight\nusing CairoMakie\n\nspacetime = FRKerrSpacetime(M = 1.0, a = 0.99, R0 = -0.0012)\n\ndistance = 750\ncamera = PinholeCamera(position = [0.0, distance, π / 2 - π / 20, 0.0],\n    horizontal_aperture_in_degrees = rad2deg(315 / distance),\n    vertical_aperture_in_degrees = rad2deg(315 / distance),\n    horizontal_number_of_pixels = 100,\n    vertical_number_of_pixels = 100)\nmodel = NovikovThorneDisk(inner_radius = 6.0, outer_radius = 18.0)\n\nconfigurations = VacuumOTEConfigurations(spacetime = spacetime,\n    camera = camera,\n    radiative_model = model,\n    unit_mass_in_solar_masses = 1.0)\n\ninitial_data = initialize(configurations)\n\ncb, cbp = callback_setup(configurations; rhorizon_bound = 2e-1) #... or, define your own cb and cbp\n\nrun = integrate(initial_data,\n    configurations,\n    cb,\n    cbp;\n    method = VCABM(),\n    reltol = 1e-13,\n    abstol = 1e-21)\n\noutput_data = run.output_data\n\nIobs = observed_bolometric_intensities(initial_data, output_data, configurations)\n\nxs, ys = axes_ranges(camera)\n\nzs = grid_view(Iobs, configurations)\n\nfig = Figure(font = \"CMU Serif\")\nax = Axis(fig[1, 1],\n    xlabel = L\"\\alpha\",\n    ylabel = L\"\\beta\",\n    ylabelsize = 26,\n    xlabelsize = 26)\nhmap = heatmap!(xs, ys, zs / maximum(zs); colormap = :gist_heat, interpolate = true)\nColorbar(fig[:, end + 1],\n    hmap,\n    label = L\"I\",\n    labelsize = 26,\n    width = 15,\n    ticksize = 18,\n    tickalign = 1)\ncolsize!(fig.layout, 1, Aspect(1, 1.0))\ncolgap!(fig.layout, 7)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"initialization/pinholecamera/#Pinhole-camera","page":"Pinhole camera","title":"Pinhole camera","text":"","category":"section"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"The energy momentum tensor of the radiation field in terms of the specific intensity is given by","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^ab = int k^a k^b left( fracI_nunu^3 right) dV_k ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where dV_k = nu dnu dOmega. Equivalently,","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^a b = int_S^2 int_0^infty n^a n^b I_nu dnu dOmega ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where n^a = k^a  nu. The radiative flux of energy in the direction of barn^a measured by an osberver with four-velocity u^a is T^a b u_a barn_b.","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"For discretizing this integral at position x^mu, we choose an orthonormal tetrad. We take","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"e_0 = partial_t \ne_1 = -partial_r \ne_2 = partial_phi \ne_3 = -partial_theta ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"and orthonormalize it with respect to g_alpha beta(x^mu), where (rtheta phi) are some topolgically spherical coordinates on the spacetime. Note that this assumes there is a timelike coordinate t and three spacelike coordinates from which there is a meaningful way of transforming to spherical-like coordinates. In flat spacetime, the interpretation of this tetrad is simple: e_1 points towards the origin, e_2 is parallel to the equatorial plane and e_3 is parallel to the z-axis. Note that the triad we use is not direct. Note also that the choice of tetrad does not actually matter. The procedure we choose is sufficiently general to allow (almost) arbitrary spacetime position, flux direction, and observer four-velocity, but it is particularly well suited for large distances in asymptotically flat spacetimes where the source can be covered by a small spherical sector centered around e_1. Finally, we take coordinates (alpha beta) on S^2 such that ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"alpha = varphi \nbeta = pi2 -vartheta","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where (vartheta varphi) are the usual angular coordinates on S^2. The coordinates range over -π le alpha lt pi and -pi2 le beta le pi2. The tetrad components of a vector in these coordinates can be written as","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"k^0 = nu  \nk^1 = nu cos alpha cos beta \nk^2 = nu sin alpha cos beta \nk^3 = nu sin beta ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Thus, in particular (alpha beta) = (00) maps to e_1. In these coordinates, dOmega = cos beta dalpha dbeta. We only need to take the (alpha beta) coordinate ranges large enough to cover the image of the emitting source. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Finally, we approximate the integral numerically as","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"sum_i j k I_ijk n^a_ij n^b_ij Delta Omega_ij Delta nu      ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where I_ijk = I_nu_k(n^a_ij), the tetrad components of n^a_ij are ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"1 cos alpha_i cos beta_j sin alpha_i cos beta_j sin beta_j ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"(we have to transform them to the coordinate frame before contraction), the solid angle of each section is","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Delta Omega_ij = int_D_ij cos beta dalpha dbeta = 2 cos(beta_j) sin left(fracDelta beta2 right) Delta alpha","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"and D_ij = alpha_i-Delta alpha2 alpha_i+Delta alpha2 times beta_j - Delta beta  2 beta_j + Delta beta 2. We took a uniform grid such that ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"alpha_i = -s_alpha2+(i-12)Delta alpha  \nbeta_j = -s_beta2+(j-12)Delta beta \nDelta alpha = s_alphaN_alpha \nDelta beta = s_betaN_beta \n1 le i le N_alpha  \n1 le j le N_beta","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":". ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where s_alpha s_beta are the horizontal and vertical aperture angles respectively, and N_alpha, N_beta are the numbers of pixels. The total solid angle is Delta Omega = 2 sin(s_beta2)s_alpha   The energy momentum tensor of the radiation field in terms of the specific intensity is given by","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^ab = int k^a k^b left( fracI_nunu^3 right) dV_k ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where dV_k = nu dnu dOmega. Equivalently,","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^a b = int_S^2 int_0^infty n^a n^b I_nu dnu dOmega ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where n^a = k^a  nu. The radiative flux of energy in the direction of barn^a measured by an osberver with four-velocity u^a is T^a b u_a barn_b.","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"For discretizing this integral at position x^mu, we choose an orthonormal tetrad. We take","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"e_0 = partial_t \ne_1 = -partial_r \ne_2 = partial_phi \ne_3 = -partial_theta ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"and orthonormalize it with respect to g_alpha beta(x^mu), where (rtheta phi) are some topolgically spherical coordinates on the spacetime. Note that this assumes there is a timelike coordinate t and three spacelike coordinates from which there is a meaningful way of transforming to spherical-like coordinates. In flat spacetime, the interpretation of this tetrad is simple: e_1 points towards the origin, e_2 is parallel to the equatorial plane and e_3 is parallel to the z-axis. Note that the triad we use is not direct. Note also that the choice of tetrad does not actually matter. The procedure we choose is sufficiently general to allow (almost) arbitrary spacetime position, flux direction, and observer four-velocity, but it is particularly well suited for large distances in asymptotically flat spacetimes where the source can be covered by a small spherical sector centered around e_1. Finally, we take coordinates (alpha beta) on S^2 such that ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"alpha = varphi \nbeta = pi2 -vartheta","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where (vartheta varphi) are the usual angular coordinates on S^2. The coordinates range over -π le alpha lt pi and -pi2 le beta le pi2. The tetrad components of a vector in these coordinates can be written as","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"k^0 = nu  \nk^1 = nu cos alpha cos beta \nk^2 = nu sin alpha cos beta \nk^3 = nu sin beta ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Thus, in particular (alpha beta) = (00) maps to e_1. In these coordinates, dOmega = cos beta dalpha dbeta. We only need to take the (alpha beta) coordinate ranges large enough to cover the image of the emitting source. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Finally, we approximate the integral numerically as","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"sum_i j k I_ijk n^a_ij n^b_ij Delta Omega_ij Delta nu      ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where I_ijk = I_nu_k(n^a_ij), the tetrad components of n^a_ij are ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"1 cos alpha_i cos beta_j sin alpha_i cos beta_j sin beta_j ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"(we have to transform them to the coordinate frame before contraction), the solid angle of each section is","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Delta Omega_ij = int_D_ij cos beta dalpha dbeta = 2 cos(beta_j) sin left(fracDelta beta2 right) Delta alpha","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"and D_ij = alpha_i-Delta alpha2 alpha_i+Delta alpha2 times beta_j - Delta beta  2 beta_j + Delta beta 2. We took a uniform grid such that ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"alpha_i = -s_alpha2+(i-12)Delta alpha  \nbeta_j = -s_beta2+(j-12)Delta beta \nDelta alpha = s_alphaN_alpha \nDelta beta = s_betaN_beta \n1 le i le N_alpha  \n1 le j le N_beta","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":". ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where s_alpha s_beta are the horizontal and vertical aperture angles respectively, and N_alpha, N_beta are the numbers of pixels. The total solid angle is Delta Omega = 2 sin(s_beta2)s_alpha","category":"page"},{"location":"#Skylight.jl","page":"Home","title":"Skylight.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(The documentation is under construction...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Skylight is a Julia package for general-relativistic ray-tracing and radiative transfer in curved spacetimes. It works with any spacetime geometry, without the constraints of specific symmetries or the assumption of asymptotic flatness. It is designed with the following goals in mind:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fast computational speed\nHigh accuracy\nEasy extensibility to user-defined spacetimes and radiative models","category":"page"},{"location":"","page":"Home","title":"Home","text":"It uses automatic differentiation from ForwardDiff.jl to compute the Christoffel symbols from the spacetime metric, and has multithreading parallelism in its compute-intensive tasks. At its core, Skylight simultaneously solves the geodesic equations and the covariant transport equations along the geodesics, i.e.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracmathopd^2 x^alphamathopdlambda^2+Gamma^alpha_mu nu fracmathopd x^mumathopdlambda fracmathopd x^numathopdlambda=0 ","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Gamma^alpha_mu nu are the Christoffel symbols of the spacetime, x^alpha is the position and lambda is an affine parameter along the geodesic, together with","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracmathopdmathopdlambda left( fracI_nunu^3right) = fracj_nunu^2 - nu alpha_nu left( fracI_nunu^3right) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"where nu is the frequency, I_nu is the intensity of the radiation field, and j_nu and alpha_nu are the emissivity and absorptivity coefficients of the medium, respectively. Skylight also has special functions for surface emission models with transport in vacuum, where the transport can be much simplified to just connecting the intensity of the radiation field between the emission and observation points. The inegration of the equations integration is performed with DifferentialEquations.jl. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Getting started for a quick start guide.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#Supported-spacetimes","page":"Home","title":"Supported spacetimes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minkowski spacetime\nSchwarzschild spacetime\nKerr spacetime\nJohannsen spacetime\nf(R)-Kerr spacetime\nRuffini-Argüelles-Rueda spacetime for fermionic dark matter\nBoson star spacetime with quartic self-interaction and solitonic potentials  \nExtensibility to user-defined spacetimes","category":"page"},{"location":"#Radiative-models","page":"Home","title":"Radiative models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Shakura-Sunyaev accretion disks\nGeometrically-thin optically-thick accretion disks with user-provided tabulated temperatures\nIon torus with synchrotron and bremsstrahlung emission \nLine emission from accretion disks with user-provided emissivity profiles\nLamppost corona emission and accretion disk illumination profiles\nExtensibility to user-defined radiative models","category":"page"},{"location":"#Geometric-and-dynamical-tools","page":"Home","title":"Geometric and dynamical tools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Geometric quantities like spacetime metrics, inverse metrics, volume elements, Christoffel symbols, etc.\nFour-vector scalar products, index raising/lowering, orthogonal projection, normalization, etc.\nConstants of motion for spacetimes with symmetries\nCharacteristic radii in certain spacetimes, like event horizons, ISCOs, etc. \nSpacetime geodesics integration","category":"page"},{"location":"#Radiative-transfer-mechanisms","page":"Home","title":"Radiative transfer mechanisms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Radiative transfer in vacuum and in emissive/absorptive media","category":"page"},{"location":"#Observable-quantities","page":"Home","title":"Observable quantities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bolometric and specific intensities in generic frames\nFluxes through arbitrarily oriented surface elements\nSpectra","category":"page"},{"location":"#Utilities","page":"Home","title":"Utilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Data loading/saving from/to HDF5 files\nUnits and dimensions management","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia version at least 1.6","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is not yet available in the Julia registries. To install it, follow these steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Clone the repository: git clone https://github.com/joaquinpelle/Skylight.jl.git\nOpen the Julia REPL and enter package mode by typing ].\nAdd Skylight to your Pkg environment: ] dev \\path\\to\\the\\repository\nImport Skylight: using Skylight","category":"page"},{"location":"#Folder-contents","page":"Home","title":"Folder contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":".\n├── docs                    # Documentation files\n├── run                     # Example scripts and notebooks to run the code\n├── src                     # Source files\n├── test                    # Test files \n│   ├── benchmarks          # Load and stress tests\n│   ├── integration         # End-to-end, integration tests\n│   └── unit                # Unit tests","category":"page"},{"location":"#To-run-the-unit-tests","page":"Home","title":"To run the unit tests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In your terminal, go to the package directory \nOpen the Julia REPL\nGo to the package mode by typing ]\nActivate the package environment by running the command activate .\nIn the package mode, run the command test","category":"page"},{"location":"#To-cite-this-work","page":"Home","title":"To cite this work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this software in your work, we kindly request that you cite the following paper","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{pelle2022skylight,\n  title={Skylight: a new code for general-relativistic ray-tracing and radiative transfer in arbitrary space--times},\n  author={Pelle, Joaquin and Reula, Oscar and Carrasco, Federico and Bederian, Carlos},\n  journal={Monthly Notices of the Royal Astronomical Society},\n  volume={515},\n  number={1},\n  pages={1316--1327},\n  year={2022},\n  publisher={Oxford University Press}\n}","category":"page"},{"location":"citing/#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citing/","page":"Citing","title":"Citing","text":"If you use this software in your work, please cite the following paper","category":"page"},{"location":"citing/","page":"Citing","title":"Citing","text":"@article{pelle2022skylight,\n  title={Skylight: a new code for general-relativistic ray-tracing and radiative transfer in arbitrary space--times},\n  author={Pelle, Joaquin and Reula, Oscar and Carrasco, Federico and Bederian, Carlos},\n  journal={Monthly Notices of the Royal Astronomical Society},\n  volume={515},\n  number={1},\n  pages={1316--1327},\n  year={2022},\n  publisher={Oxford University Press}\n}","category":"page"},{"location":"radiativetransfer/radiativetransfer/#Radiative-transfer","page":"Radiative transfer","title":"Radiative transfer","text":"","category":"section"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"examples/corona_kerr/#Lamppost-corona-above-a-Kerr-black-hole","page":"Lamppost corona above a Kerr black hole","title":"Lamppost corona above a Kerr black hole","text":"","category":"section"},{"location":"examples/corona_kerr/","page":"Lamppost corona above a Kerr black hole","title":"Lamppost corona above a Kerr black hole","text":"using Skylight\nusing CairoMakie\nusing Printf\n\nspacetime = KerrSpacetimeBoyerLindquistCoordinates(M=1.0, a=0.0)\ndisk = NovikovThorneDisk(inner_radius = isco_radius(spacetime, ProgradeRotation()), outer_radius = 100.0)\ncorona = LamppostCorona(height=height, theta_offset=1e-5, spectral_index = 2.0)\nconfigurations = VacuumETOConfigurations(spacetime=spacetime,\n                                radiative_model = corona,\n                                number_of_points=1,\n                                number_of_packets_per_point = npp, \n                                max_radius = 110.0,\n                                unit_mass_in_solar_masses=1.0)\ninitial_data = initialize(configurations)\ncbp = callback_parameters(spacetime, disk, configurations; rhorizon_bound=2e-3)\ncb = callback(spacetime, disk)\nsim = integrate(initial_data, configurations, cb, cbp; method=VCABM(), reltol=1e-5, abstol=1e-5)\noutput_data = sim.output_data\n\nI, bins_midpoints = emissivity_profile(output_data, spacetime, disk, corona)\n\nfig = Figure(resolution=(400,400))\nax = Axis(fig[1,1])\nlines!(ax, bins_midpoints, I)\nax.xscale = log10\nax.yscale = log10\n# xlims!(1.0,200)\n# ylims!(1e-6, 1e0)\nax.xtickformat = \"{:.1f}\"\ndisplay(fig)","category":"page"},{"location":"radiativemodels/radiativemodels/#Radiative-models","page":"Radiative models","title":"Radiative models","text":"","category":"section"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"radiativemodels/catalogue/#Catalogue-of-radiative-models","page":"Catalogue","title":"Catalogue of radiative models","text":"","category":"section"},{"location":"spacetimes/functions/","page":"Functions","title":"Functions","text":"Modules = [Skylight]\nOrder = [:function]","category":"page"},{"location":"spacetimes/functions/#Skylight.allocate_cache-Tuple{AbstractSpacetime}","page":"Functions","title":"Skylight.allocate_cache","text":"allocate_cache(spacetime)\n\nAllocate a cache object for the given spacetime. The cache object is used to store temporary data in spacetime-related calculations.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.allocate_christoffel_cache-Tuple{AbstractSpacetime}","page":"Functions","title":"Skylight.allocate_christoffel_cache","text":"allocate_christoffel_cache(spacetime)\n\nAllocate a cache object for the Christoffel symbols calculation. Unless a more specific method is defined, an instance of Skylight.AutoDiffChristoffelCache is returned.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.approximate_gradient_norm-Tuple{Array, Real, Real}","page":"Functions","title":"Skylight.approximate_gradient_norm","text":"approximate_gradient_norm(z::Array, dx_spacing::Real, dy_spacing::Real)\n\nCompute the norm of the gradient of a function given a 2D grid of function values z and grid spacings dx_spacing and dy_spacing.\n\nThe gradient is computed using central differences in the interior and forward or backward differences at the edges.\n\nArguments\n\nz::Array: 2D grid of function values.\ndx_spacing::Real: Grid spacing in the x direction.\ndy_spacing::Real: Grid spacing in the y direction.\n\nReturns\n\ngrad_norm::Array: 2D grid of gradient magnitudes.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.average_inside_bins-NTuple{5, Any}","page":"Functions","title":"Skylight.average_inside_bins","text":"average_inside_bins(q, x, y, xbins, ybins)\n\nCalculate the averages of a quantity q at values (x,y) in each bin defined by xbins and ybins.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.average_inside_bins-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.average_inside_bins","text":"average_inside_bins(q, x, bins)\n\nCalculate the averages of a quantity q at value x in each bin defined by bins.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.axial_symmetry-Tuple{AbstractSpacetime}","page":"Functions","title":"Skylight.axial_symmetry","text":"axial_symmetry(spacetime)\n\nReturn IsAxiallySymmetric() if the spacetime is axially symmetric, IsNotAxiallySymmetric() otherwise.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.bin_values_and_sum_weights-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.bin_values_and_sum_weights","text":"bin_values_and_sum_weights(bins, values, weights)\n\nBin values and sum weights in each bin.\n\nArguments\n\nbins: Array of bin edges.\nvalues: Array of values to be binned.\nweights: Array of weights to be summed in each bin.\n\nReturns\n\nbinned_values: Array of the sum of weights in each bin.\n\nNotes\n\nThe length of values and weights must be the same.\nValues outside the range of bins are ignored.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.christoffel!-Tuple{Any, Any, AbstractSpacetime, Nothing}","page":"Functions","title":"Skylight.christoffel!","text":"christoffel!(Γ, position, spacetime, cache)\n\nEvaluate the Christoffel symbols at the given position and store the result in the given array using cache for temporary storage. Unless a more specific method is defined, automatic differentiation is used to compute the Christoffel symbols.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.christoffel!-Tuple{Any, Any, AbstractSpacetime, Skylight.AutoDiffChristoffelCache}","page":"Functions","title":"Skylight.christoffel!","text":"\" Calculates the Christoffel symbols of a given spacetime metric using the forward-mode automatic differentiation package ForwardDiff.\n\nArguments:\n\nΓ₂: mutable array of size (4,4,4) to store the resulting Christoffel symbols.\nposition: tuple of four numbers representing a position in spacetime.\nspacetime: object representing the spacetime.\ncache: object of type AutoDiffChristoffelCache with containers for metric elements and derivatives.\n\nReturns: nothing.\n\nNote: for the automatic differentiation to work on a given spacetime, any spacetime cache array used in  metric calculations must be wrapped by the DiffCache() method as:\n\n```\n@with_kw mutable struct KerrSpacetimeCache{T} <: AbstractSpacetimeCache\n    l::T = DiffCache(zeros(4))\nend\n```\n\nThis is because automatic differentiation keeps two versions of each variable, a Real and a Dual version, the latter being used to compute derivatives at each node of the chain rule. Also, in the metric!(g, position, spacetime) function, the caches must be accessed via the function get_tmp as in get_tmp(spacetime.l, position), so that the appropriate version of the cache is returned according to the element type of position when metric! is called.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.circular_geodesic_angular_speed-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.circular_geodesic_angular_speed","text":"circular_geodesic_angular_speed(position, spacetime, rotation_sense::AbstractRotationSense)\n\nAngular speed of a circular geodesic at the given position in the given spacetime for a particle rotating in the given sense.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.circular_geodesic_energy-Tuple{Any, FRKerrSpacetime, AbstractRotationSense}","page":"Functions","title":"Skylight.circular_geodesic_energy","text":"Set for M=1\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.circular_geodesic_specific_angular_momentum-Tuple{Any, FRKerrSpacetime, AbstractRotationSense}","page":"Functions","title":"Skylight.circular_geodesic_specific_angular_momentum","text":"Set for M=1\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.compose_N_times-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.compose_N_times","text":"compose_N_times(N, f, x)\n\nCompose function f to the input x for N times.\n\nArguments\n\nN: The number of times to apply the function f.\nf: The function to be applied.\nx: The input to the function f.\n\nExample\n\nmatrix = rand(Bool, 5, 5)\ncompose_N_times(3, detect_edges, matrix)\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.cos_angle_between_null_vectors-NTuple{4, Any}","page":"Functions","title":"Skylight.cos_angle_between_null_vectors","text":"The cosine of the angle between null vectors v and w as seen by observer at normalized four-velocity u\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.cos_angle_between_vectors-NTuple{4, Any}","page":"Functions","title":"Skylight.cos_angle_between_vectors","text":"The cosine of the angle between vectors v and w as seen by observer at normalized four-velocity\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.det2x2-Tuple{Any}","page":"Functions","title":"Skylight.det2x2","text":"Computes the determinant of a 2x2 matrix using a closed-form formula.\n\nArguments:\n\nmatrix: array of size (2,2) containing the input matrix.\n\nReturns: the determinant of the input matrix.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.det2x2sym-Tuple{Any}","page":"Functions","title":"Skylight.det2x2sym","text":"Computes the determinant of a 2x2 symmetric matrix using a closed-form formula.\n\nArguments:\n\nmatrix: array of size (2,2) containing the input symmetric matrix.\n\nReturns: the determinant of the input matrix.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.det4x4sym-Tuple{Any}","page":"Functions","title":"Skylight.det4x4sym","text":"Computes the determinant of a 4x4 symmetric matrix using a closed-form formula.\n\nArguments:\n\nmatrix: array of size (4,4) containing the input symmetric matrix.\n\nReturns: the determinant of the input matrix.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.detect_edges-Tuple{Int64, Union{BitMatrix, Matrix{Bool}}}","page":"Functions","title":"Skylight.detect_edges","text":"detect_edges(N, arr)\n\nDetects values that are at distance at most N from an edge. Composes detect_edges to  the input arr for 1 to N times, and combines the results using an elementwise OR operation.  Each application of detect_edges is performed on the result of the previous application and the results are combined in succession.\n\nArguments\n\nN::Int: The maximum number of times to apply the function f.\narr::Union{Matrix{Bool}, BitMatrix}: The boolean array.\n\nExample\n\njulia matrix = rand(Bool, 5, 5) detect_edges(3, matrix)` In this example, the detect_edges function is applied 1 to 3 times to a 5x5 random Boolean matrix, and the results are combined with an OR operation.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.detect_edges-Tuple{Union{BitMatrix, Matrix{Bool}}}","page":"Functions","title":"Skylight.detect_edges","text":"detect_edges(arr::Array{Bool, 2})\n\nDetects edges in a two-dimensional Boolean array by comparing each element with its neighbors in all four cardinal directions (up, down, left, and right). An edge is considered to be present at a location if the Boolean value at that location is different from the value of any of its neighbors.\n\nArguments\n\narr::Array{Bool, 2}: a two-dimensional Boolean array.\n\nReturns\n\nArray{Bool, 2}: a two-dimensional Boolean array of the same size as the input, where true indicates the presence of an edge and false indicates its absence.\n\nNotes\n\nThis function assumes that the input array is padded with false (or 0) at the boundaries. You might want to add boundary condition checking or padding if your input does not meet this condition.\nThis function uses \"edge wrapping\" when it shifts the array, meaning the values at the edge of the array \"wrap around\" to the opposite edge. If you want a different boundary condition (such as padding with false), you would need to adjust the creation of the shifted arrays accordingly.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.emissivity_profile-Tuple{AbstractMatrix, AbstractSpacetime, AbstractAccretionDisk, LamppostCorona}","page":"Functions","title":"Skylight.emissivity_profile","text":"Assumes unit energy in the rest frame of the emitter\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.energies_quotients-Tuple{AbstractMatrix, AbstractSpacetime, AbstractAccretionDisk}","page":"Functions","title":"Skylight.energies_quotients","text":"Assuming all photons are emitted with unit initial energy\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.equatorial_ring_areas-Tuple{AbstractVector, AbstractSpacetime}","page":"Functions","title":"Skylight.equatorial_ring_areas","text":"equatorial_ring_areas(edges, spacetime)\n\nApproximate areas of the equatorial rings delimited by edges in spacetime. The spacetime must be stationary and axisymmetric. The areas are computed using the formula 2π*sqrt(g[2,2]*g[4,4])*Δr, where g is the metric evaluated at the center of the ring.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.event_horizon_radius-Tuple{Any}","page":"Functions","title":"Skylight.event_horizon_radius","text":"event_horizon_radius(spacetime)\n\nRadius of the event horizon of the given spacetime. Defined only for black hole spacetimes.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.horizons-Tuple{FRKerrSpacetime}","page":"Functions","title":"Skylight.horizons","text":"May return negative roots\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.infer_num_bins-NTuple{7, Any}","page":"Functions","title":"Skylight.infer_num_bins","text":"infer_num_bins(q, at_source, start, stop, bin_size_conditioner, edge_width, camera)\n\nInfer the number of bins from the energy quotients and the bin size conditioner. It chooses the larges number of bins that satisfies that the bin size is larger than the conditioner times the maximum local variation of the energy quotients, for a given approximation of the local variation.\n\nArguments\n\nq: Array of energy quotients.\nat_source: Array of booleans indicating whether the final position is at the source.\nstart: Lower bound of the range to be binned.\nstop: Upper bound of the range to be binned.\nbin_size_conditioner: Conditioner of the bin size.\nedge_width: Width of the edge to be ignored for bin size conditioning (since edges have unusually large local variations, especially in the presence of light-rings and similar phenomena).\ncamera: Image plane.\n\nReturns\n\nnum_bins: Number of bins.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.initialize-Tuple{PinholeCamera, Skylight.AbstractOTEConfigurations}","page":"Functions","title":"Skylight.initialize","text":"Sets the bundle of rays at the camera position. The rays are initialized on a tetrad which has a static four-velocity and  a spherical-like spatial triad. The rays have unit energy in this tetrad.  See docs/pinholecamera.md for more details\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.instantiate_custom_type-Tuple{Dict{Symbol}}","page":"Functions","title":"Skylight.instantiate_custom_type","text":"instantiate_custom_type(dict)\n\nCreate an instance of a custom type using a dictionary. This version supports custom types created using the @with_kw macro from the Parameters.jl package and handles nested dictionaries. The dictionary and its nested subdictionaries must contain a _typename key whose value is the name of the custom type. \n\nArguments\n\ndict::Dict{Symbol, }: A dictionary containing the custom type's name (stored in the _typename key) and field values.\n\nReturns\n\nAn instance of the custom type with the field values specified in the input dictionary, including instances created from nested dictionaries.\n\nExample\n\n```julia using Parameters\n\n@with_kw struct MyNestedType     a::Int end\n\n@with_kw struct MyTypeWithKW     b::Float64     nested::MyNestedType end\n\nmydict = Dict(:typename => \"MyTypeWithKW\",                :b => 2.0,                :nested => Dict(:_typename => \"MyNestedType\",                                :a => 1))\n\nmyinstance = instantiatecustomtype(mydict)\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.inv4x4sym!-Tuple{Matrix{Float64}, Matrix{Float64}}","page":"Functions","title":"Skylight.inv4x4sym!","text":"Computes the inverse of a 4x4 symmetric matrix using the closed-form solution for the inverse.\n\nArguments:\n\ninv_matrix: mutable array of size (4,4) to store the resulting inverse matrix.\nmatrix: array of size (4,4) containing the input symmetric matrix.\n\nReturns: nothing.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.is_final_position_at_edge-Tuple{Any, Any}","page":"Functions","title":"Skylight.is_final_position_at_edge","text":"is_final_position_at_edge(output_data, configurations)\n\nDetermine whether the final position of each ray is at the edge of the source for a given set of configurations.\n\nArguments\n\noutput_data: a multi-dimensional array containing output data for each ray.\nconfigurations: a data structure containing the spacetime and radiative model configurations.\n\nReturns\n\nA boolean grid indicating whether each ray's final position is at the edge of the source.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.is_final_position_at_edge-Tuple{Int64, Any, Any}","page":"Functions","title":"Skylight.is_final_position_at_edge","text":"is_final_position_at_edge(width::Int, output_data, configurations)\n\nDetermine whether the final position of each ray is at the edge of the source for a given set of configurations, considering a specified edge width.\n\nArguments\n\nwidth: the width (in number of cells) to consider as the edge of the source.\noutput_data: a multi-dimensional array containing output data for each ray.\nconfigurations: a data structure containing the spacetime and radiative model configurations.\n\nReturns\n\nA boolean grid indicating whether each ray's final position is within the specified width of the edge of the source.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.is_final_position_at_observer-Tuple{Any, Any}","page":"Functions","title":"Skylight.is_final_position_at_observer","text":"is_final_position_at_observer(output_data, configurations)\n\nDetermine whether the final position of each ray is at the observer for a given set of configurations.\n\nArguments\n\noutput_data: a multi-dimensional array containing output data for each ray.\nconfigurations: a data structure containing the spacetime and radiative model configurations.\n\nReturns\n\nA boolean grid indicating whether each ray's final position is at the observer.\n\nNotes\n\nThe function is_final_position_at_observer should already be defined elsewhere, and is used within this function to check the final position of each ray.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.is_final_position_at_source-Tuple{AbstractMatrix, Any}","page":"Functions","title":"Skylight.is_final_position_at_source","text":"is_final_position_at_source(output_data, configurations)\n\nDetermine whether the final position of each ray is at the source for a given set of configurations.\n\nArguments\n\noutput_data: a multi-dimensional array containing output data for each ray.\nconfigurations: a data structure containing the spacetime and radiative model configurations.\n\nReturns\n\nA boolean grid indicating whether each ray's final position is at the source.\n\nNotes\n\nThe function is_final_position_at_source should already be defined elsewhere, and is used within this function to check the final position of each ray.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.is_hdf5_supported_type-Tuple{Any}","page":"Functions","title":"Skylight.is_hdf5_supported_type","text":"is_hdf5_supported_type(value)\n\nCheck if a given value is of a type that can be directly saved using the HDF5.jl package. This function can be used to determine whether a custom type or one of its fields can be saved to an HDF5 file without further conversion.\n\nAccording to the HDF5.jl documentation, the supported types include:\n\nSigned and unsigned integers (8, 16, 32, and 64 bits)\nFloat32 and Float64\nComplex versions of numeric types\nArrays of supported numeric types (including complex versions)\nAbstractString (ASCIIString and UTF8String)\nArrays of supported string types (ASCIIString and UTF8String)\n\nArguments\n\nvalue: The value to be checked for HDF5 support.\n\nReturns\n\nA Bool indicating whether the input value is of a type supported by HDF5.jl.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.isco_radius-Tuple{Any, Any}","page":"Functions","title":"Skylight.isco_radius","text":"isco_radius(spacetime, rotation_sense::AbstractRotationSense)\n\nRadius of the innermost stable circular orbit in the given spacetime and rotation sense (prograde or  retrograde), if defined.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.isco_radius-Tuple{FRKerrSpacetime, AbstractRotationSense}","page":"Functions","title":"Skylight.isco_radius","text":"Set for M=1\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.line_emission_spectrum-Tuple{Any, Any, VacuumOTEConfigurations}","page":"Functions","title":"Skylight.line_emission_spectrum","text":"line_emission_spectrum(initial_data, output_data, configurations::VacuumOTEConfigurations; \n                       bin_size::Number=NaN, num_bins::Int=NaN,\n                       start::Number=NaN, stop::Number=NaN)\n\nCompute the binned intensity of a line emission spectrum.\n\nArguments\n\ninitial_data: Initial condition data.\noutput_data: Output data from the radiation model.\nconfigurations::VacuumOTEConfigurations: Configuration parameters for the model.\n\nKeywords\n\nbin_size::Union{Nothing, Number}=nothing: Size of each bin. Either bin_size or num_bins must be specified.\nnum_bins::Union{Nothing, Number}=nothing: Number of bins. Either bin_size or num_bins must be specified.\nstart::Union{Nothing, Number}=nothing: Lower bound of the range to be binned. If unspecified, the minimum of the energy quotients will be used.\nstop::Union{Nothing, Number}=nothing: Upper bound of the range to be binned. If unspecified, the maximum of the energy quotients will be used.\nobserver_four_velocity::AbstractVector (optional): The four-velocity of the observer. If not provided, a default static four-velocity will be used.\nflux_direction::AbstractVector (optional): The direction in which to measure the flu. If not provided, a default direction will be used.\n\nReturns\n\nbinned_fluxes: Array of the binned intensity in each bin.\nbins: Array of the bin edges.\n\nNotes\n\nobserver_four_velocity and flux_direction are only accepted if configurations.camera is a PinholeCamera.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_callback_params_from_hdf5-Tuple{String, Int64}","page":"Functions","title":"Skylight.load_callback_params_from_hdf5","text":"load_callback_params_from_hdf5(filename::String, run_index::Int)\n\nLoad the callback parameters of a specific run from an HDF5 file and instantiate the custom type if possible.\n\nArguments\n\nfilename: The path to the HDF5 file.\nrun_index: The index of the run to load the callback parameters from.\n\nReturns\n\nAn instance of the custom type representing the callback parameters, or a dictionary if the custom type cannot be instantiated.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_configurations_from_hdf5-Tuple{String}","page":"Functions","title":"Skylight.load_configurations_from_hdf5","text":"load_configurations_from_hdf5(filename::String)\n\nLoad configurations data from an HDF5 file.\n\nArguments\n\nfilename::String: The path to the HDF5 file.\n\nReturns\n\nAn instance of the configuration type containing the configurations data stored in the HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_initial_data_from_hdf5-Tuple{String}","page":"Functions","title":"Skylight.load_initial_data_from_hdf5","text":"load_initial_data_from_hdf5(filename::String)\n\nLoad initial data from an HDF5 file.\n\nArguments\n\nfilename::String: The path to the HDF5 file.\n\nReturns\n\nThe initial data stored in the HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_nested_dict_from_hdf5-Tuple{HDF5.Group}","page":"Functions","title":"Skylight.load_nested_dict_from_hdf5","text":"load_nested_dict_from_hdf5(group::HDF5Group)\n\nConvert an HDF5 group to a dictionary. If the value is \"nothing\", the value in the dict will be nothing.\n\nArguments\n\ngroup::HDF5Group: The HDF5 group to convert to a dictionary.\n\nReturns\n\nA dictionary containing the data stored in the HDF5 group.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_output_data_from_hdf5-Tuple{String, Int64}","page":"Functions","title":"Skylight.load_output_data_from_hdf5","text":"load_output_data_from_hdf5(filename::String, run_index::Int)\n\nLoad the output data of a specific run from an HDF5 file.\n\nArguments\n\nfilename: The path to the HDF5 file.\nrun_index: The index of the run to load the output data from.\n\nReturns\n\nThe output data of the specified run.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_output_data_from_hdf5-Tuple{String, Vector{Int64}}","page":"Functions","title":"Skylight.load_output_data_from_hdf5","text":"load_output_data_from_hdf5(filename::String, run_indices::Vector{Int})\n\nLoad output data for a selected set of runs from an HDF5 file.\n\nArguments\n\nfilename::String: The path to the HDF5 file.\nrun_indices::Vector{Int}: A vector of integers indicating which runs' output data to load.\n\nReturns\n\nAn array containing the output data for the selected runs.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_runs_from_hdf5-Tuple{String, Vector{Int64}}","page":"Functions","title":"Skylight.load_runs_from_hdf5","text":"load_runs(filename::String, run_indices::Vector{Int})\n\nLoad a set of runs specified by their indices from an HDF5 file.\n\nArguments\n\nfilename: The path to the HDF5 file.\nrun_indices: A vector containing the indices of the runs to be loaded.\n\nReturns\n\nA vector of tuples, each containing the outputdata, callback dictionary, callbackparameters, and kwargs dictionary for the specified runs.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.lorentz_factors-Tuple{AbstractMatrix, AbstractSpacetime, AbstractRadiativeModel}","page":"Functions","title":"Skylight.lorentz_factors","text":"lorentz_factors(positions, spacetime, model)\n\nLorentz factors of the rest frame four velocities of `model` at given `positions`.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.mbco_radius-Tuple{Any, Any}","page":"Functions","title":"Skylight.mbco_radius","text":"mbco_radius(spacetime, rotation_sense::AbstractRotationSense)\n\nRadius of the marginally bound circular orbit in the given spacetime and rotation sense (prograde or retrograde), if defined.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.mbco_radius-Tuple{FRKerrSpacetime, AbstractRotationSense}","page":"Functions","title":"Skylight.mbco_radius","text":"Set for M=1\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric!-NTuple{4, Any}","page":"Functions","title":"Skylight.metric!","text":"metric!(g, position, spacetime, cache)\n\nEvaluate the spacetime metric at the given position and store the result in the given array using cache for temporary storage.  \n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric!-Tuple{Any, Any, RARSpacetime}","page":"Functions","title":"Skylight.metric!","text":"\"Ruffini-Arguelles-Rueda metric for dark-matter halo\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric-Tuple{Any, AbstractSpacetime, Any}","page":"Functions","title":"Skylight.metric","text":"metric(position, spacetime, cache)\n\nEvaluate the spacetime metric at the given position and return the result using a cache object as temporary storage. \n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric-Tuple{Any, AbstractSpacetime}","page":"Functions","title":"Skylight.metric","text":"metric(position, spacetime)\n\nEvaluate the spacetime metric at the given position and return the result. \n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric_inverse!-Tuple{Any, Any, AbstractSpacetime, Any, Any}","page":"Functions","title":"Skylight.metric_inverse!","text":"metric_inverse!(ginv, position, spacetime, g, cache)\n\nEvaluate the inverse of the metric at the given position  and store the result in the given array, using g and cache for temporary storage. Unless a more specialized method is defined, a fast inversion method for 4x4 symmetric matrices is used.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric_jacobian!-Tuple{Any, Any, AbstractSpacetime, Any, Any}","page":"Functions","title":"Skylight.metric_jacobian!","text":"metric_jacobian!(∂g, position, spacetime::AbstractSpacetime, g)\n\nComputes the Jacobian matrix of the metric function with respect to spacetime coordinates using forward-mode automatic differentiation.\n\nArguments:\n\n∂g: mutable array of size (4,4,4) to store the resulting Jacobian matrix.\nposition: tuple of four numbers representing a position in spacetime.\nspacetime: object representing the spacetime.\ng: array of size (4,4) containing the metric evaluated at the given position.\n\nReturns: nothing.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric_jacobian!-Tuple{Any, Any, Function, Any, ForwardDiff.JacobianConfig}","page":"Functions","title":"Skylight.metric_jacobian!","text":"metric_jacobian!(∂g, position, spacetime_metric_field::Function, g, cfg::ForwardDiff.JacobianConfig)\n\nComputes the Jacobian matrix of the metric function with respect to spacetime coordinates using forward-mode automatic differentiation.\n\nArguments:\n\n∂g: mutable array of size (4,4,4) to store the resulting Jacobian matrix.\nposition: tuple of four numbers representing a position in spacetime.\nspacetime: object representing the spacetime.\ng: array of size (4,4) containing the metric evaluated at the given position.\ncfg: object of type ForwardDiff.JacobianConfig with preallocated work buffers \n\nReturns: nothing.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.midpoints-Tuple{AbstractVector}","page":"Functions","title":"Skylight.midpoints","text":"midpoints(edges)\n\nReturns midpoints of given edges\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.observed_bolometric_intensities-Tuple{AbstractMatrix, AbstractMatrix, VacuumOTEConfigurations, PinholeCamera}","page":"Functions","title":"Skylight.observed_bolometric_intensities","text":"observedbolometricintensities(initialdata, outputdata, configurations::VacuumOTEConfigurations, camera::PinholeCamera; observerfourvelocity=nothing) \n\nCompute observed bolometric intensities and energy quotients for a set of rays defined by the initial and final conditions. The function also checks whether the final position of each ray is at the source, in which case it proceeds with computation, else it skips to the next ray and the values are set to zero. \n\n# Arguments\n\ninitial_data::AbstractMatrix: A matrix containing the initial data of the rays. The first four entries for each ray represent the initial position, while entries five to eight represent the initial momentum.\noutput_data::AbstractMatrix: A matrix containing the final data of the rays. The first four entries for each ray represent the final position, while entries five to eight represent the final momentum.\nconfigurations::VacuumOTEConfigurations: The configurations with which the initial and output data were obtained.\ncamera::PinholeCamera: The camera model used to capture the scene.\nobserver_four_velocity::AbstractVector (optional): The four-velocity of the observer. If not provided, a default static four-velocity will be used.\n\nReturns\n\nIobs::Vector: A vector of observed bolometric intensities for each ray, normalized by the distance to the image plane. The intensities are in CGS units.\nq::Vector: A vector of energy quotients for each ray, representing the ratio of final energy in the local emission frame to initial energy in the observer frame.\n\nNotes\n\nOutput units are CGS. The observer four-velocity and flux direction, if provided, must satisfy the conditions of being timelike and spacelike, respectively, as per the observer metric.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.observed_specific_intensities-Tuple{AbstractMatrix, AbstractMatrix, VacuumOTEConfigurations, ImagePlane, AbstractVector}","page":"Functions","title":"Skylight.observed_specific_intensities","text":"observed_specific_intensities(initial_data, output_data, configurations::VacuumOTEConfigurations)\n\nCompute observed specific intensities and energy quotients for a set of rays defined by the initial and final conditions. The function also checks whether the final position of each ray is at the source, in which case it proceeds with computation, else it skips to the next ray and the values are set to zero.\n\nArguments\n\ninitial_data::AbstractMatrix: A matrix containing the initial data of the rays. The first four entries for each ray represent the initial position, while entries five to eight represent the initial momentum.\noutput_data::AbstractMatrix: A matrix containing the final data of the rays. The first four entries for each ray represent the final position, while entries five to eight represent the final momentum.\nconfigurations::VacuumOTEConfigurations: The configurations with which the initial and output data were obtained.\nobservation_energies::Vector: A vector of energies in CGS units at which the specific intensities are to be computed.\n\nReturns\n\nIobs::Vector: A vector of observed specific intensities in CGS units for each ray, normalized by the distance to the image plane. The intensities are in CGS units.\nq::Vector: A vector of energy quotients for each ray, representing the ratio of final energy in the local emisison frame to initial energy in the observer frame.\n\nNotes\n\nInput energy units must be CGS. Output units are CGS.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.observed_specific_intensities-Tuple{AbstractMatrix, AbstractMatrix, VacuumOTEConfigurations, PinholeCamera, Any}","page":"Functions","title":"Skylight.observed_specific_intensities","text":"observed_specific_intensities(initial_data, output_data, configurations::VacuumOTEConfigurations, observation_energies; observer_four_velocity=nothing)\n\nCompute observed specific intensities and energy quotients for a set of rays defined by the initial and final conditions. The function also checks whether the final position of each ray is at the source, in which case it proceeds with computation, else it skips to the next ray and the values are set to zero.\n\nArguments\n\ninitial_data::AbstractMatrix: A matrix containing the initial data of the rays. The first four entries for each ray represent the initial position, while entries five to eight represent the initial momentum.\noutput_data::AbstractMatrix: A matrix containing the final data of the rays. The first four entries for each ray represent the final position, while entries five to eight represent the final momentum.\nconfigurations::VacuumOTEConfigurations: The configurations with which the initial and output data were obtained.\nobservation_energies::Vector: A vector of energies in CGS units at which the specific intensities are to be computed.\nobserver_four_velocity::AbstractVector (optional): The four-velocity of the observer. If not provided, a default static four-velocity will be used.\n\nReturns\n\nIobs::Matrix: A matrix of observed specific intensities in CGS units for each ray, normalized by the distance to the image plane. The intensities are in CGS units.\nq::Vector: A vector of energy quotients for each ray, representing the ratio of final energy in the local emission frame to initial energy in the observer frame.\n\nNotes\n\nInput energy units must be CGS. Output units are CGS. The observer four-velocity and flux direction, if provided, must satisfy the conditions of being timelike and spacelike, respectively, as per the observer metric.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.orthogonal_projection-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.orthogonal_projection","text":"Projection of v orthogonal to normalized timelike vector u\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.orthonormalize!-NTuple{4, Any}","page":"Functions","title":"Skylight.orthonormalize!","text":"orthonormalize!(dyad::Matrix, time_vector::Vector, space_vector::Vector, metric)\n\nOrthonormalize the dyad `dyad` with respect to the metric `metric` and the vectors `time_vector` and `space_vector`.\nBoth `time_vector` and `space_vector` are assumed to be normalized and orthogonal to each other.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.orthonormalize!-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.orthonormalize!","text":"orthonormalize!(triad::Matrix, time_vector::Vector, metric)\n\nOrthonormalize the triad `triad` with respect to the metric `metric` and the vector `time_vector`.\n`time_vector` is assumed to be normalized.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.outermost_circular_orbit_radius-Tuple{FRKerrSpacetime, AbstractRotationSense}","page":"Functions","title":"Skylight.outermost_circular_orbit_radius","text":"Just return 100M, this if for ion torus\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.packets_tetrad_components!-Tuple{Any, Any}","page":"Functions","title":"Skylight.packets_tetrad_components!","text":"By having Minkowski-null components in the tetrad we guarantee that the momentum is null\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.packets_unit_random_triad_components!-Tuple{Any, Skylight.IsOpaqueInteriorSurface}","page":"Functions","title":"Skylight.packets_unit_random_triad_components!","text":"Sets only positive components along the surface normal\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.planck_function-Tuple{Any, Any}","page":"Functions","title":"Skylight.planck_function","text":"planck_function(E, T)\n\nPlanck's law of black body radiation in terms of energy.\n\nArguments\n\nE::Float64: The energy in erg.\nT::Float64: The temperature in Kelvin.\n\nReturns\n\n::Float64: The planck function in CGS.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.planck_integral-Tuple{Any, Any}","page":"Functions","title":"Skylight.planck_integral","text":"planck_integral(E, T)\n\nEstimation of the Planck integral from E to infinity for temperature T.  Based on \"Planck functions and integrals; methods of computation\" (T.E. Michels) https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19680008986.pdf\n\nArguments\n\nE::Float64: The energy in erg.\nT::Float64: The temperature in Kelvin.\n\nReturns\n\n::Float64: The planck integral in CGS.\n\nRemarks\n\nAn evaluation of the error is too expensive for millions of calls, so we fix N=5. This was checked against scipy integration, yielding at least 3 siginficant digits for all x. When x>1 the amount of siginificant digits is 8 or more\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.points_on_equatorial_plane!-Tuple{Any, Any, Any, CartesianTopology}","page":"Functions","title":"Skylight.points_on_equatorial_plane!","text":"points_on_equatorial_plane!(points, r, φ, ::CartesianTopology)\n\nSets the points on the equatorial plane from spherical coordinates\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.points_on_unit_sphere!-Tuple{Any, Any, Any, CartesianTopology}","page":"Functions","title":"Skylight.points_on_unit_sphere!","text":"points_on_unit_sphere!(points, θ, φ, ::AbstractCoordinatesTopology)\n\nTransforms the points on the unit sphere from the angular coordinates\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.radius-Tuple{Any, Any}","page":"Functions","title":"Skylight.radius","text":"radius(position, spacetime)\n\nRadius of the given position in the given spacetime. \n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.radius-Tuple{Any, SchwarzschildSpacetimeKerrSchildCoordinates}","page":"Functions","title":"Skylight.radius","text":"radius(position, spacetime::SchwarzschildSpacetimeKerrSchildCoordinates)\n\n``r = \\sqrt{x^2 + y^2 + z^2}``\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_azimuthal_angle-Tuple{Any}","page":"Functions","title":"Skylight.random_azimuthal_angle","text":"random_azimuthal_angle(N)\n\nGenerates N random numbers representing azimuthal angles, following a  uniform distribution from 0 to 2π.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_cylindrical_radius-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.random_cylindrical_radius","text":"random_cylindrical_radius(N, rmin, rmax)\n\nGenerates N random numbers representing cylindrical radii, following a  uniform distribution between rmin and rmax.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_polar_angle-Tuple{Any, Any}","page":"Functions","title":"Skylight.random_polar_angle","text":"random_polar_angle(N, θmax)\n\nGenerates N random numbers representing polar angles, following a  uniform distribution from 0 to θmax (in radians).\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_uniform_points_annulus!-NTuple{4, Any}","page":"Functions","title":"Skylight.random_uniform_points_annulus!","text":"random_uniform_points_annulus!(points, rmin, rmax, coords_top)\n\nPopulate the given array points with points randomly and uniformly  distributed in an annulus with inner radius rmin and outer radius rmax. The type of the coordinate system is determined by coords_top.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_uniform_points_disk!-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.random_uniform_points_disk!","text":"random_uniform_points_disk!(points, rmax, coords_top)\n\nPopulate the given array points with points randomly and uniformly  distributed in a disk with radius rmax. The type of the coordinate system is determined by coords_top.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_uniform_points_unit_hemisphere!-Tuple{Any, Any}","page":"Functions","title":"Skylight.random_uniform_points_unit_hemisphere!","text":"random_uniform_points_unit_hemisphere!(points, coords_top)\n\nPopulate the given array points with points randomly and uniformly  distributed on the unit hemisphere. The type of the coordinate system is determined by coords_top.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_uniform_points_unit_hemisphere_xaxis!-Tuple{Any, CartesianTopology}","page":"Functions","title":"Skylight.random_uniform_points_unit_hemisphere_xaxis!","text":"random_uniform_points_unit_hemisphere_xaxis!(v,::CartesianTopology)\n\nPopulate the given array v with points randomly and uniformly  distributed on the unit hemisphere along the x-axis.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_uniform_points_unit_sphere!-Tuple{Any, Any}","page":"Functions","title":"Skylight.random_uniform_points_unit_sphere!","text":"random_uniform_points_unit_sphere!(points, coords_top)\n\nPopulate the given array points with points randomly and uniformly  distributed on the unit sphere. The type of the coordinate system is determined by coords_top.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_uniform_points_unit_spherical_cap!-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.random_uniform_points_unit_spherical_cap!","text":"random_uniform_points_unit_spherical_cap!(points, θmax_in_degrees, coords_top)\n\nPopulate the given array points with points randomly and uniformly  distributed in a spherical cap with maximum polar angle θmax_in_degrees degrees. The type of the coordinate system is determined by coords_top.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.rayleigh_jeans_function-Tuple{Any, Any}","page":"Functions","title":"Skylight.rayleigh_jeans_function","text":"rayleigh_jeans_function(E, T)\n\nRayleigh-Jeans law of black body radiation in terms of energy.\n\nArguments\n\nE::Float64: The energy in erg.\nT::Float64: The temperature in Kelvin.\n\nReturns\n\n::Float64: The Rayleigh-Jeans function in CGS.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.rays_tetrad_components!-Tuple{Any, PinholeCamera}","page":"Functions","title":"Skylight.rays_tetrad_components!","text":"By having Minkowski-null components in the tetrad we guarantee that the momentum is null\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.save_nested_dict_to_hdf5-Tuple{Any, Any}","page":"Functions","title":"Skylight.save_nested_dict_to_hdf5","text":"save_nested_dict_to_hdf5(group::HDF5File, nested_dict::Dict{Symbol,})\n\nRecursively save a nested dictionary to an HDF5 group. The function iterates through the key-value pairs in the input dictionary. If a value is a dictionary, it creates a new subgroup and recursively saves the nested dictionary. If a value is not a dictionary, it is saved directly to the current group.\n\nArguments\n\ngroup: An HDF5 group to which the nested dictionary should be saved.\nnested_dict: A nested dictionary with keys of type Symbol and values of any type.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.save_obj_to_hdf5-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.save_obj_to_hdf5","text":"save_obj_to_hdf5(group::HDF5File, name::String, obj::Any)\n\nSave an object to an HDF5 group by converting it to an HDF5 compatible dictionary and then saving the dictionary to the group. The function creates a new subgroup with the given name and saves the converted dictionary using the save_nested_dict_to_hdf5 function.\n\nArguments\n\ngroup: An HDF5 group to which the object should be saved.\nname: A string representing the name of the subgroup to create for the object.\nobj: An object of any type that should be saved to the HDF5 group.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.save_to_hdf5-Union{Tuple{T}, Tuple{String, AbstractConfigurations, Array, Array{T}}} where T<:Skylight.Run","page":"Functions","title":"Skylight.save_to_hdf5","text":"save_to_hdf5(filename, configurations, initial_data, runs)\n\nSave the provided data to an HDF5 file. The data includes configurations, initialdata, and a collection of runs. Each run contains outputdata, callback, callback_parameters, and kwargs for the solver function.\n\nIf the file exists, it uses the \"r+\" mode to open the file for reading and writing. If the file does not exist, it uses the \"w\" mode to create a new file.\n\nThe file will be organized as follows:\n\n/configurations: A group containing the configurations data.\n/initial_data: A dataset containing the initial data.\n/runs: A group containing subgroups for each run. Each subgroup will have:\n/output_data: A dataset containing the output data.\n/callback: A subgroup containing the callback custom type data.\n/callback_parameters: A subgroup containing the callback parameters data.\n/kwargs: A subgroup containing the kwargs data.\n\nArguments\n\nfilename: The name of the HDF5 file to save the data to. If the file already exists, new data will be appended without overwriting existing content.\nconfigurations: A custom type containing the configurations data. It will be converted to a dictionary using the to_hdf5_compatible_dict function.\ninitial_data: The initial data for the equations.\nruns: An array of tuples containing outputdata, callback custom type, callbackparameters, and kwargs for each run. The callback custom type and callbackparameters should be custom types, which will be converted to dictionaries using the `tohdf5compatibledict` function.\n\nReturns\n\nNothing.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.set_null!-Tuple{Any, Any}","page":"Functions","title":"Skylight.set_null!","text":"returns with unit energy\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.set_null_ingoing_past_directed!-Tuple{Any, Any}","page":"Functions","title":"Skylight.set_null_ingoing_past_directed!","text":"the input time component must be zero for this to work \n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.spherical_symmetry-Tuple{AbstractSpacetime}","page":"Functions","title":"Skylight.spherical_symmetry","text":"spherical_symmetry(spacetime)\n\nReturn IsSphericallySymmetric() if the spacetime is spherically symmetric, IsNotSphericallySymmetric() otherwise.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.stationarity-Tuple{AbstractSpacetime}","page":"Functions","title":"Skylight.stationarity","text":"stationarity(spacetime)\n\nReturn IsStationary() if the spacetime is stationary, IsNotStationary() otherwise.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.tmap-Tuple{Any, Any, Vararg{Any}}","page":"Functions","title":"Skylight.tmap","text":"tmap(f, itr; tasks_per_thread::Int = 2, kwargs...)\n\nApply a given function f to partitions of the iterable itr in parallel.\n\nArguments\n\nf: A function to be applied to each partition of the iterable.\nitr: The iterable to be partitioned and processed.\ntasks_per_thread::Int: An optional parameter to control the number of tasks per thread. Default value is 2.\nkwargs...: Additional keyword arguments that will be passed to the function f.\n\nDescription\n\nThis function divides the iterable itr into chunks, with each chunk size determined by the given tasks_per_thread and the number of available threads. The specified function f is then applied to each chunk in parallel using the @spawn macro. The @sync macro ensures that all tasks are completed before moving on.\n\nExample\n\n```julia function printelements(chunk)     for i in chunk         println(i)     end end tmap(printelements, 1:10; tasksperthread = 2)\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.to_hdf5_compatible_dict-Tuple{T} where T","page":"Functions","title":"Skylight.to_hdf5_compatible_dict","text":"to_hdf5_compatible_dict(obj::T; depth::Int=0, max_depth::Int=5) where T\n\nRecursively convert a custom type obj to a dictionary. This function is useful for preparing custom types for saving to an HDF5 file when the types are not directly supported by the HDF5.jl package.\n\nThe function will attempt to convert each field of the custom type to a dictionary if the field is not an HDF5-supported type. The conversion process is limited by a maximum recursion depth, specified by the max_depth parameter, which defaults to 5.\n\nIf a field is nothing, the value will be saved as the string \"nothing\".\n\nIf a field is a function, the function will be converted to a string using the string function.\n\nIf a field is not an HDF5-supported type and has no fields that can be converted, the function will return nothing when the maximum recursion depth is reached.\n\nArguments\n\nobj::T: The custom type instance to be converted to a dictionary.\ndepth::Int=0 (optional): The current recursion depth, starting at 0. This parameter is used internally and should not typically be set by the user.\nmax_depth::Int=5 (optional): The maximum recursion depth allowed for converting nested custom types.\n\nReturns\n\nA Dict{String, Any} containing the fields of the input custom type, with nested custom types recursively converted to dictionaries. The dictionary will also include a \"_typename\" key with the name of the custom type as a string.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.to_hdf5_compatible_dict-Tuple{T} where T<:SciMLBase.DECallback","page":"Functions","title":"Skylight.to_hdf5_compatible_dict","text":"to_hdf5_compatible_dict(cb::T; depth::Int=0, max_depth::Int=8) where {T<:SciMLBase.DECallback}\n\nConverts a DifferentialEquations.jl callback into a dictionary that can be saved to an HDF5 file for later instantiation.\n\nArguments\n\ncb: The callback to be converted into a dictionary.\ndepth: The current depth of recursion. This is used to prevent infinite recursion.  (default: 0)\nmax_depth: The maximum allowed depth of recursion. If the depth exceeds this value,  the function returns nothing. (default: 8)\n\nReturns\n\nA dictionary where the keys are the names of the fields of the object and the values are  the corresponding field values. Field values are recursively converted to dictionaries  if they are of custom types not supported by HDF5.jl.\n\nNotes\n\nThe dictionary includes an additional entry with the key \"_typename\" and the name of the type  of the object as the value. This is used to reconstruct the original object when loading  the data from the HDF5 file.\nThe function specifically handles certain fields of the DECallback type.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.volume_element-Tuple{Any, AbstractSpacetime, Any, Any}","page":"Functions","title":"Skylight.volume_element","text":"volume_element(position, spacetime, g, cache)\n\nCompute the volume element (square root of minus the determinant of the metric) at the given position  with a fast determinant for 4x4 symmetric matrices, using g and cache for temporary storage.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.volume_element-Tuple{Any, AbstractSpacetime}","page":"Functions","title":"Skylight.volume_element","text":"volume_element(position, spacetime)\n\nCompute the volume element (square root of minus the determinant of the metric) at the given position  with a fast determinant for 4x4 symmetric matrices.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/autodiff/#Automatic-differentiation","page":"Automatic differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"spacetimes/autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"Unless a more specialized method is available, the Christoffel symbols of a given spacetime are calculated using forward-mode automatic differentiation from the metric coefficients, using functionality from the ForwardDiff package. ","category":"page"},{"location":"spacetimes/autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"Skylight.AutoDiffChristoffelCache","category":"page"},{"location":"spacetimes/autodiff/#Skylight.AutoDiffChristoffelCache","page":"Automatic differentiation","title":"Skylight.AutoDiffChristoffelCache","text":"AutoDiffChristoffelCache{F, CA, CO} <: AbstractChristoffelCache\n\nCache object for temporary storage in Christoffel symbol calculation via automatic differentiation. \n\nConstructor\n\nAutoDiffChristoffelCache(spacetime::AbstractSpacetime)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Catalogue-of-spacetimes","page":"Catalogue","title":"Catalogue of spacetimes","text":"","category":"section"},{"location":"spacetimes/catalogue/","page":"Catalogue","title":"Catalogue","text":"Modules = [Skylight]\nFilter = t -> typeof(t) === DataType && t <: Skylight.AbstractSpacetime && isconcretetype(t)","category":"page"},{"location":"spacetimes/catalogue/#Skylight.BosonStarSpacetime","page":"Catalogue","title":"Skylight.BosonStarSpacetime","text":"BosonStarSpacetime <: AbstractRegularCompactObjectSpacetime\n\nBoson star spacetime in spherical coordinates. It uses analyical fits. Either the  fit parameters as described in... can be provided as vectors, or any of the symbols :LBS1,  :LBS2, :LBS3, :SBS1, :SBS2 or :SBS3 as constructor arguments\n\nConstructors\n\nBosonStarSpacetime(a=aparams, b=bparams) \nBosonStarSpacetime(:LBS1)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.ChargedWormholeSpacetimeRegularCoordinates","page":"Catalogue","title":"Skylight.ChargedWormholeSpacetimeRegularCoordinates","text":"ChargedWormholeSpacetimeRegularCoordinates <: AbstractSpacetime\n\nCharged wormhole spacetime  in regular (throat crossing) coordinates.\n\nConstructor\n\nChargedWormholeSpacetimeRegularCoordinates(b0=1.0, Q=0.5)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.ChargedWormholeSpacetimeSphericalCoordinates","page":"Catalogue","title":"Skylight.ChargedWormholeSpacetimeSphericalCoordinates","text":"ChargedWormholeSpacetimeSphericalCoordinates <: AbstractSpacetime\n\nCharged wormhole spacetime  in usual spherical coordinates.\n\nConstructor\n\nChargedWormholeSpacetimeSphericalCoordinates(b0=1.0, Q=0.5)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.FRKerrSpacetime","page":"Catalogue","title":"Skylight.FRKerrSpacetime","text":"FRKerrSpacetime <: AbstractBlackHoleSpacetime\n\nf(R)-Kerr spacetime  (uncharged) with constant curvature R_0\n\nConstructor\n\nFRKerrSpacetime(M=1.0, a=0.99, R0=-0.0012) \n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.JohannsenSpacetime","page":"Catalogue","title":"Skylight.JohannsenSpacetime","text":"JohannsenSpacetime <: AbstractBlackHoleSpacetime\n\nJohannsen spacetime to lowest order in the  deformation parameters with respect to the Kerr metric\n\nConstructor\n\nJohannsenSpacetime(M=1.0, a=0.99, α13=0.5, α22=0.0, α52=0.01, ϵ3=0.0)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.KerrSpacetimeBoyerLindquistCoordinates","page":"Catalogue","title":"Skylight.KerrSpacetimeBoyerLindquistCoordinates","text":"KerrSpacetimeBoyerLindquistCoordinates <: AbstractKerrSpacetime\n\nKerr spacetime in Boyer-Lindquist coordinates. The parameter are the mass M and the  dimensionless spin a. \n\nConstructor\n\nKerrSpacetimeBoyerLindquistCoordinates(M=1.0, a=0.99)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.KerrSpacetimeKerrSchildCoordinates","page":"Catalogue","title":"Skylight.KerrSpacetimeKerrSchildCoordinates","text":"KerrSpacetimeKerrSchildCoordinates <: AbstractKerrSpacetime\n\nKerr spacetime in Kerr-Schild coordinates. The parameter are the mass M and the  dimensionless spin a. The metric is\n\ng_mu nu = eta_mu nu + H l_mu l_nu\n\nwhere eta_mu nu is the flat metric, H=2Mr^3(r^4+a^2 z^2, and \n\nl_mu=(1fracrx+ayr^2+a^2fracry-axr^2+a^2zr)\n\nwhere r satisfies the equation\n\nfracx^2+y^2r^2+a^2 + fracz^2r^2 = 1\n\nConstructor\n\nKerrSpacetimeKerrSchildCoordinates(M=1.0, a=0.99)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.MinkowskiSpacetimeCartesianCoordinates","page":"Catalogue","title":"Skylight.MinkowskiSpacetimeCartesianCoordinates","text":"MinkowskiSpacetimeCartesianCoordinates <: AbstractSpacetime\n\nMinkowski Spacetime in spherical coordinates. \n\nds^2 = -dt^2 + dx^2 + dy^2 + dz^2\n\nConstructor\n\nMinkowskiSpacetimeCartesianCoordinates()\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.MinkowskiSpacetimeSphericalCoordinates","page":"Catalogue","title":"Skylight.MinkowskiSpacetimeSphericalCoordinates","text":"MinkowskiSpacetimeSphericalCoordinates <: AbstractSpacetime\n\nMinkowski Spacetime in spherical coordinates. \n\nds^2 = -dt^2 + dr^2 + r^2 dtheta^2 + r^2 sin^2 theta dphi^2\n\nwhere r is the radial coordinate and θ is the polar angle.\n\nConstructor\n\nMinkowskiSpacetimeSphericalCoordinates()\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.SchwarzschildSpacetimeKerrSchildCoordinates","page":"Catalogue","title":"Skylight.SchwarzschildSpacetimeKerrSchildCoordinates","text":"SchwarzschildSpacetimeKerrSchildCoordinates <: AbstractSchwarzschildSpacetime\n\nSchwarzschild spacetime in Kerr-Schild coordinates. The parameter M is the mass. The metric is\n\ng_mu nu = eta_mu nu + H l_mu l_nu\n\nwhere eta_mu nu is the flat metric, H=2Mr, and l_mu=(1xyz)r.\n\nConstructor\n\nSchwarzschildSpacetimeKerrSchildCoordinates(M=1.0)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.SchwarzschildSpacetimeSphericalCoordinates","page":"Catalogue","title":"Skylight.SchwarzschildSpacetimeSphericalCoordinates","text":"SchwarzschildSpacetimeSphericalCoordinates <: AbstractSchwarzschildSpacetime\n\nSchwarzschild spacetime in spherical coordinates. The metric is\n\nds^2 = -(1-2Mr) dt^2 + (1-2Mr)^-1 dr^2 + r^2 dtheta^2 + r^2 sin^2 theta dphi^2\n\nConstructor\n\nSchwarzschildSpacetimeSphericalCoordinates(M=1.0)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/","page":"Catalogue","title":"Catalogue","text":"Skylight.RARSpacetime","category":"page"},{"location":"spacetimes/catalogue/#Skylight.RARSpacetime","page":"Catalogue","title":"Skylight.RARSpacetime","text":"RARSpacetime <: AbstractRegularCompactObjectSpacetime\n\nRuffini-Arguelles-Rueda spacetime for dark-matter galactic core-halo. The spacetime is constructed by interpolating the data files in a given directory. The numerical data must include the r, g_tt, g_rr, partial_r nu, M(r) and partial_r M as columns in that order. The data must be in geometrized  units.\n\nConstructor\n\nRARSpacetime(\"./rar_data\")\n\n\n\n\n\n","category":"type"},{"location":"initialization/imageplane/#Image-plane","page":"Image plane","title":"Image plane","text":"","category":"section"},{"location":"initialization/imageplane/","page":"Image plane","title":"Image plane","text":"When the observer is far away from the source in an asymptotically flat spacetime, the image of the source is a small region of the celestial sphere. The image plane is the plane tangent to the celestial sphere at the observer's position. In that case, the rays can be assumed to be almost parallel, and the angular integral can be reparameterized in terms of impact parameters. This was Skylight's original construction, as it is described in its paper, but this version will be deprecated, since it is much less general, and it is not much faster than the general version that allows for arbitrary observation position and four-velocity.","category":"page"},{"location":"examples/skylightlogo/#Skylight's-logo","page":"Skylight's logo","title":"Skylight's logo","text":"","category":"section"},{"location":"examples/skylightlogo/","page":"Skylight's logo","title":"Skylight's logo","text":"Skylight's logo is produced with Skylight itself, mapping Julia's logo onto a screen behind a Kerr black hole and ray tracing the image seen by an observer aligned with the black hole and the screen. You can play with the logo by changing the parameters of the configuration in the following snippet, where you need to replace original_image = load(\"julia-logo.png\") with the path to your own image file:","category":"page"},{"location":"examples/skylightlogo/","page":"Skylight's logo","title":"Skylight's logo","text":"\nusing Skylight\nusing Images\n\nfunction main(original_image,\n    filename;\n    spin = 0.0,\n    d_obs_screen,\n    rel_bh_pos,\n    bh_size,\n    xaperture,\n    n_factor = 1)\n    nx, ny = size(original_image)\n\n    obs_x = d_obs_screen * (1 - rel_bh_pos)\n    xscreen = obs_x - d_obs_screen\n    # xaperture = 60\n    ximage = 1.0 / bh_size\n\n    Nx = floor(Int, nx * n_factor)\n    Ny = floor(Int, ny * n_factor)\n\n    spacetime = KerrSpacetimeKerrSchildCoordinates(M = 1.0, a = spin)\n    camera = PinholeCamera(position = [0.0, obs_x, 0.0, 0.0],\n        horizontal_aperture_in_degrees = xaperture, #rad2deg(70/distance),\n        vertical_aperture_in_degrees = (ny / nx) * xaperture, #rad2deg(70/distance),\n        horizontal_number_of_pixels = Nx,\n        vertical_number_of_pixels = Ny)\n    model = VerticalScreen(x = xscreen,\n        horizontal_side = ximage,\n        vertical_side = (ny / nx) * ximage)\n    configurations = VacuumOTEConfigurations(spacetime = spacetime,\n        camera = camera,\n        radiative_model = model,\n        unit_mass_in_solar_masses = 1.0)\n    initial_data = initialize(configurations)\n    cb, cbp = callback_setup(configurations; rmax = 500.0, rhorizon_bound = 2e-1) #... or, define your own cb and cbp\n    run = integrate(initial_data,\n        configurations,\n        cb,\n        cbp;\n        method = VCABM(),\n        reltol = 1e-13,\n        abstol = 1e-21)\n    output_data = run.output_data\n\n    # Create a new blank image with the same size as the original image\n    new_image = imresize(original_image, (Nx, Ny))\n\n    for j in 1:Ny\n        for i in 1:Nx\n            ipx = (j - 1) * Nx + i\n            x, y, z = output_data[2:4, ipx]\n            if !(x ≈ model.x) || abs(y) > 0.5 * model.horizontal_side ||\n               abs(z) > 0.5 * model.vertical_side\n                new_image[i, j] = zero(eltype(original_image))\n                continue\n            end\n\n            in = floor(Int,\n                1 + nx * (y + 0.5 * model.horizontal_side) / model.horizontal_side)\n            jn = floor(Int, 1 + ny * (z + 0.5 * model.vertical_side) / model.vertical_side)\n\n            if 1 <= in <= size(new_image, 1) && 1 <= jn <= size(new_image, 2)\n                # Copy the pixel value from the original image to the new image\n                new_image[i, j] = original_image[in, jn]\n            else\n                println(\"Pixel ($i, $j) is outside the new image, warning\")\n            end\n        end\n    end\n\n    # Save the new image\n    # display(new_image)\n    save(filename, new_image)\nend\n\noriginal_image = load(\"julia-logo.png\")\nspin = 0.0\nobs_x = 40.0\nxscreen = -20.0\nximage = 30.0\nxaperture = 60\nn_factor = 1\n\nmain(original_image,\n    \"logo.png\";\n    d_obs_screen = 230.0,\n    rel_bh_pos = 3 / 23,\n    bh_size = 1 / 15.0,\n    xaperture = 10,\n    n_factor = 3)","category":"page"},{"location":"examples/torus_kerr/#Ion-torus-in-Kerr-spacetime","page":"Ion torus around a Kerr black hole","title":"Ion torus in Kerr spacetime","text":"","category":"section"},{"location":"examples/torus_kerr/","page":"Ion torus around a Kerr black hole","title":"Ion torus around a Kerr black hole","text":"\nusing Skylight\nusing CairoMakie\n\ndistance = 500\nN = 400\nspacetime = KerrSpacetimeBoyerLindquistCoordinates(M = 1.0, a = 0.5)\ncamera = PinholeCamera(position = [0.0, distance, π * (1 / 2 - 1 / 18), 0.0],\n    horizontal_aperture_in_degrees = rad2deg(atan(20 / distance)),\n    vertical_aperture_in_degrees = rad2deg(atan(20 / distance)),\n    horizontal_number_of_pixels = N,\n    vertical_number_of_pixels = N)\nmodel = IonTorus(spacetime)\nconfigurations = NonVacuumOTEConfigurations(spacetime = spacetime,\n    camera = camera,\n    radiative_model = model,\n    unit_mass_in_solar_masses = 1.0,\n    observation_energies = exp10.(range(-10, stop = -5.5, length = 20)))\ninitial_data = initialize(configurations)\ncb, cbp = callback_setup(configurations; rhorizon_bound = 2e-1) #... or, define your own cb and cbp\nrun = integrate(initial_data,\n    configurations,\n    cb,\n    cbp;\n    method = VCABM(),\n    reltol = 1e-8,\n    abstol = 1e-8)\noutput_data = run.output_data\n\n#Image\nxs, ys = axes_ranges(camera)\nzs = grid_view(output_data, configurations; energy_index = 1)\n\nzs[zs .< 1e-40] .= 1e-40\nzs = log10.(zs)\nlogzmin = minimum(zs[zs .> -40])\nlogzmax = maximum(zs)\n\nfig = Figure(font = \"CMU Serif\") #resolution=(600,400)\nax = Axis(fig[1, 1],\n    xlabel = L\"\\alpha\",\n    ylabel = L\"\\beta\",\n    ylabelsize = 26,\n    xlabelsize = 26)\nhmap = heatmap!(xs,\n    ys,\n    zs;\n    colormap = :gist_heat,\n    interpolate = true,\n    colorrange = (logzmax - 10, logzmax))\nColorbar(fig[:, end + 1],\n    hmap,\n    label = L\"I\",\n    labelsize = 26,\n    width = 15,\n    ticksize = 18,\n    tickalign = 1)\ncolsize!(fig.layout, 1, Aspect(1, 1.0))\ncolgap!(fig.layout, 7)\nCairoMakie.save(\"torus_image.png\", fig)\n\n#Spectrum\nF = spectrum(initial_data, output_data, configurations)\nν = erg_to_Hz(configurations.observation_energies)\n\nfig = Figure()\nax = Axis(fig[1, 1],\n    xlabel = L\"\\nu \\, [\\text{Hz}]\",\n    ylabel = L\"\\nu F_{\\nu} \\,[\\text{erg} \\,\\text{s}^{-1}\\,\\text{Hz}^{-1}]\",\n    xscale = log10,\n    yscale = log10,\n    xlabelsize = 26,\n    ylabelsize = 26)\nlines!(ax, ν, ν .* Hz_to_erg(F); linewidth = 2.0, color = :blue)\nCairoMakie.save(\"torus_spectrum.png\", fig)\ndisplay(fig)\n\n#Potential\npotential = (x, z) -> Skylight.torus_normalized_potential([\n        0.0,\n        sqrt(x^2 + z^2),\n        acos(z / sqrt(x^2 + z^2)),\n        0.0,\n    ],\n    spacetime,\n    model)\n\nsize = 10\nN = 200\nx_vals = LinRange(0.0, size, N)\nz_vals = LinRange(0.0, size, N)\nw_vals = [potential(x, z) for x in x_vals, z in z_vals]\n\nw_vals[w_vals .< 0.0] .= 1e-40\nwmin = minimum(w_vals[w_vals .> 1e-40])\nwmax = maximum(w_vals)\n\nfig = Figure()\nax = Axis(fig[1, 1])\nimg = heatmap!(x_vals,\n    z_vals,\n    log10.(w_vals),\n    colormap = cmap,\n    interpolate = true,\n    colorrange = (log10(wmin), log10(wmax)))\n\ncbar = Colorbar(fig[1, 2], img, label = \"Normalized potential\", ticklabelpad = 10) \nfig","category":"page"},{"location":"initialization/initialization/#Initialization","page":"Initialization","title":"Initialization","text":"","category":"section"},{"location":"miscellanea/misc/#Miscellanea","page":"Miscellanea","title":"Miscellanea","text":"","category":"section"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"In the observer-to-emitter scheme the initial momenta are past-directed and pointing inwards. To see why this is valid cosider the following: the Lioville vector field on the tangent bundle of spacetime is the vector field which generates the geodesic flow. The component of this field along the fibers is invariant to sign inversion on the fiber. This means that the geodesic passing through the point (x^μk^μ) and the one passing through (x^μ-k^μ) project to the same curve on the base spacetime. We do it this way so the geodesic integrator kernel is common to both transport schemes. Otherwise, although the physical equations would be the same, the numerical integrators would have to be different because we would have to take backward steps in the observer-to-emitter case. Once we have the solutions, we can invert the sign of k^μ if necessary when we use it elsewhere. ","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"ispositionat_source should't be used in condition/affect. Its purpose is to classify the endstate of a geodesic already stopped, not to condition the geodesic integration.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Callback params needs to have an rmax.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Coordinates are assumed to be have either cartesian or spherical topology, and to be ordered like (t r theta varphi) or (t x y z). The first coordinate is assumed to be temporal, and the other three spatial. This is checked for in the initialization via the metric signature.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"AbstractAccretionDisk assumes innerradius and outerradius as fields.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"The integrator can integrate geodesics of any kind (timelike and spacelike too)","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Custom initial data can be provided as well to the integrator as an array of size (8 N) where N is the number of rays.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"The intensity integrated in non-vacuum is the invariant intensity","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"The emissivity must take vectors of energies as inputs","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Setting the absorptovity function to return nothing is equivalent to setting the absorptivity to zero","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"The non-vacuum transfer equations only work towards the past because of rest frame energy sign assumption. This will be generalized.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Observation energies in non-vacuum are assumed to be in CGS.","category":"page"},{"location":"miscellanea/porting_from_c/#Tips-for-porting-a-metric-from-C","page":"Tips for porting a metric from C","title":"Tips for porting a metric from C","text":"","category":"section"},{"location":"miscellanea/porting_from_c/","page":"Tips for porting a metric from C","title":"Tips for porting a metric from C","text":"Change function to metric! and arguments to g, position, spacetime\nExtract t,x,y,z = position\nRemove all variable declarations\nRemove all remaining double\nRemove all ; (be careful there are no two or more commands in one line)\nReplace all // by  (checkout for C macros before)\nReplace result[i] by resulti\nUse regular expressions to replace pow(base, exp) as follows: 8.1. Find pow(([^,]),\\s([^)]+)) using Reg Ex 8.2. Replace by (1)^(2) \nReplace gcov by g (just for consistency)\nReplace return\" by return nothing\"\nRemove all unused variables \nIn case of keeping arrays, shift indexes because Julia is 1-based (whereas C is 0-based)  To do this you can search for the regular expression (\\w+)[\\s(\\d+)\\s] and replace by 12+1]  After that you can search all (1+1) and replace by 2 and so on.  In case there is [][] or other type of indexing you need to generalize the RegEx\nRemove final } and add end\nReplace ++ by +=1\nReplace integers that are used in ifs and whiles by booleans (or minimally you can change by e.g. while(keep_iterating==1)) and then replace keep_iterating=1 by keep_iterating=true and keep_iterating=0 by keep_iterating=false","category":"page"},{"location":"radiativetransfer/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"postprocess/postprocess/#Postprocess","page":"Postprocess","title":"Postprocess","text":"","category":"section"}]
}
