var documenterSearchIndex = {"docs":
[{"location":"initialization/imageplane/#Image-plane","page":"Image plane","title":"Image plane","text":"","category":"section"},{"location":"initialization/imageplane/","page":"Image plane","title":"Image plane","text":"When the observer is far away from the source in an asymptotically flat spacetime, the image of the source is a small region of the celestial sphere. The image plane is the plane tangent to the celestial sphere at the observer's position. In that case, the rays can be assumed to be almost parallel, and the angular integral can be reparameterized in terms of impact parameters. This was Skylight's original construction, as it is described in its paper, but this version will be deprecated, since it is much less general, and it is not much faster than the general version that allows for arbitrary observation position and four-velocity.","category":"page"},{"location":"postprocess/postprocess/#Postprocess","page":"Postprocess","title":"Postprocess","text":"","category":"section"},{"location":"publications/#Publications","page":"Publications","title":"Publications","text":"","category":"section"},{"location":"publications/","page":"Publications","title":"Publications","text":"This software has been utilized in the following publications","category":"page"},{"location":"publications/","page":"Publications","title":"Publications","text":"Pelle, J., Reula, O., Carrasco, F., & Bederian, C. (2022). Skylight: a new code for general-relativistic ray-tracing and radiative transfer in arbitrary space–times. Monthly Notices of the Royal Astronomical Society, 515(1), 1316-1327.\nCarrasco, F., Pelle, J., Reula, O., Viganò, D., & Palenzuela, C. (2023). Relativistic force-free models of the thermal X-ray emission in millisecond pulsars observed by NICER. Monthly Notices of the Royal Astronomical Society, 520(2), 3151-3163.\nNeto, M. R., Perez, D., & Pelle, J. (2023). The shadow of charged traversable wormholes. International Journal of Modern Physics D, 32(02), 2250137.\nRosa, J. L., Pelle, J, & Perez, D. (2024). Accretion disks and relativistic line broadening in boson star spacetimes.","category":"page"},{"location":"examples/disk_kerr/#Thin-disk-around-a-Kerr-black-hole","page":"Thin disk around a Kerr black hole","title":"Thin disk around a Kerr black hole","text":"","category":"section"},{"location":"examples/disk_kerr/","page":"Thin disk around a Kerr black hole","title":"Thin disk around a Kerr black hole","text":"using Skylight\nusing CairoMakie\n\nspacetime = KerrSpacetimeBoyerLindquistCoordinates(M = 1.0, a = 0.9)\n\ncamera = ImagePlane(distance = 500.0,\n    observer_inclination_in_degrees = 90,\n    horizontal_side = 23.0,\n    vertical_side = 23.0,\n    horizontal_number_of_pixels = 100,\n    vertical_number_of_pixels = 100)\n\nmodel = NovikovThorneDisk(inner_radius = isco_radius(spacetime), outer_radius = 18.0)\n\nconfigurations = VacuumOTEConfigurations(spacetime = spacetime,\n    camera = camera,\n    radiative_model = model,\n    unit_mass_in_solar_masses = 1.0)\n\ninitial_data = initialize(configurations)\n\ncb, cbp = callback_setup(configurations; rhorizon_bound = 2e-1) #... or, define your own cb and cbp\n\nrun = integrate(initial_data,\n    configurations,\n    cb,\n    cbp;\n    method = VCABM(),\n    reltol = 1e-13,\n    abstol = 1e-21)\n\noutput_data = run.output_data\n\nIobs = observed_bolometric_intensities(initial_data, output_data, configurations)\n\nxs, ys = axes_ranges(camera)\n\nzs = grid_view(Iobs, configurations)\n\nfig = Figure(font = \"CMU Serif\")\nax = Axis(fig[1, 1],\n    xlabel = L\"\\alpha\",\n    ylabel = L\"\\beta\",\n    ylabelsize = 26,\n    xlabelsize = 26)\nhmap = heatmap!(xs, ys, zs / maximum(zs); colormap = :gist_heat, interpolate = true)\nColorbar(fig[:, end + 1],\n    hmap,\n    label = L\"I\",\n    labelsize = 26,\n    width = 15,\n    ticksize = 18,\n    tickalign = 1)\ncolsize!(fig.layout, 1, Aspect(1, 1.0))\ncolgap!(fig.layout, 7)\nCairoMakie.save(\"plot.png\", fig)","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Contributions are welcome! Feel free to open an issue or a pull request.","category":"page"},{"location":"examples/corona_kerr/#Lamppost-corona-above-a-Kerr-black-hole","page":"Lamppost corona above a Kerr black hole","title":"Lamppost corona above a Kerr black hole","text":"","category":"section"},{"location":"examples/corona_kerr/","page":"Lamppost corona above a Kerr black hole","title":"Lamppost corona above a Kerr black hole","text":"using Skylight\nusing CairoMakie\nusing Printf\n\nspacetime = KerrSpacetimeBoyerLindquistCoordinates(M=1.0, a=0.0)\ndisk = DummyDisk(inner_radius = isco_radius(spacetime, ProgradeRotation()), outer_radius = 100.0)\ncorona = LamppostCorona(height=height, theta_offset=1e-5, spectral_index = 2.0)\nconfigurations = VacuumETOConfigurations(spacetime=spacetime,\n                                radiative_model = corona,\n                                number_of_points=1,\n                                number_of_packets_per_point = npp, \n                                max_radius = 110.0,\n                                unit_mass_in_solar_masses=1.0)\ninitial_data = initialize(configurations)\ncbp = callback_parameters(spacetime, disk, configurations; rhorizon_bound=2e-3)\ncb = callback(spacetime, disk)\nsim = integrate(initial_data, configurations, cb, cbp; method=VCABM(), reltol=1e-5, abstol=1e-5)\noutput_data = sim.output_data\n\nI, bins_midpoints = emissivity_profile(output_data, spacetime, disk, corona)\n\nfig = Figure(resolution=(400,400))\nax = Axis(fig[1,1])\nlines!(ax, bins_midpoints, I)\nax.xscale = log10\nax.yscale = log10\n# xlims!(1.0,200)\n# ylims!(1e-6, 1e0)\nax.xtickformat = \"{:.1f}\"\ndisplay(fig)","category":"page"},{"location":"radiativetransfer/radiativetransfer/#Radiative-transfer","page":"Radiative transfer","title":"Radiative transfer","text":"","category":"section"},{"location":"examples/skylightlogo/#Skylight-logo","page":"Skylight logo","title":"Skylight logo","text":"","category":"section"},{"location":"examples/skylightlogo/","page":"Skylight logo","title":"Skylight logo","text":"Skylight logo is produced with Skylight itself, mapping the three-dots Julia logo onto a screen behind a Kerr black hole and ray tracing the image for an observer aligned with the black hole and the screen. Play with the logo by changing the parameters of the configuration in the following snippet, where you need to replace original_image = load(\"julia-logo.png\") with the path to your own image file:","category":"page"},{"location":"examples/skylightlogo/","page":"Skylight logo","title":"Skylight logo","text":"\nusing Skylight\nusing Images\n\nfunction main(original_image,\n    filename;\n    spin = 0.0,\n    d_obs_screen,\n    rel_bh_pos,\n    bh_size,\n    xaperture,\n    n_factor = 1)\n    nx, ny = size(original_image)\n\n    obs_x = d_obs_screen * (1 - rel_bh_pos)\n    xscreen = obs_x - d_obs_screen\n    # xaperture = 60\n    ximage = 1.0 / bh_size\n\n    Nx = floor(Int, nx * n_factor)\n    Ny = floor(Int, ny * n_factor)\n\n    spacetime = KerrSpacetimeKerrSchildCoordinates(M = 1.0, a = spin)\n    camera = PinholeCamera(position = [0.0, obs_x, 0.0, 0.0],\n        horizontal_aperture_in_degrees = xaperture, #rad2deg(70/distance),\n        vertical_aperture_in_degrees = (ny / nx) * xaperture, #rad2deg(70/distance),\n        horizontal_number_of_pixels = Nx,\n        vertical_number_of_pixels = Ny)\n    model = VerticalScreen(x = xscreen,\n        horizontal_side = ximage,\n        vertical_side = (ny / nx) * ximage)\n    configurations = VacuumOTEConfigurations(spacetime = spacetime,\n        camera = camera,\n        radiative_model = model,\n        unit_mass_in_solar_masses = 1.0)\n    initial_data = initialize(configurations)\n    cb, cbp = callback_setup(configurations; rmax = 500.0, rhorizon_bound = 2e-1) #... or, define your own cb and cbp\n    run = integrate(initial_data,\n        configurations,\n        cb,\n        cbp;\n        method = VCABM(),\n        reltol = 1e-13,\n        abstol = 1e-21)\n    output_data = run.output_data\n\n    # Create a new blank image with the same size as the original image\n    new_image = imresize(original_image, (Nx, Ny))\n\n    for j in 1:Ny\n        for i in 1:Nx\n            ipx = (j - 1) * Nx + i\n            x, y, z = output_data[2:4, ipx]\n            if !(x ≈ model.x) || abs(y) > 0.5 * model.horizontal_side ||\n               abs(z) > 0.5 * model.vertical_side\n                new_image[i, j] = zero(eltype(original_image))\n                continue\n            end\n\n            in = floor(Int,\n                1 + nx * (y + 0.5 * model.horizontal_side) / model.horizontal_side)\n            jn = floor(Int, 1 + ny * (z + 0.5 * model.vertical_side) / model.vertical_side)\n\n            if 1 <= in <= size(new_image, 1) && 1 <= jn <= size(new_image, 2)\n                # Copy the pixel value from the original image to the new image\n                new_image[i, j] = original_image[in, jn]\n            else\n                println(\"Pixel ($i, $j) is outside the new image, warning\")\n            end\n        end\n    end\n\n    # Save the new image\n    # display(new_image)\n    save(filename, new_image)\nend\n\noriginal_image = load(\"julia-logo.png\")\nspin = 0.0\nobs_x = 40.0\nxscreen = -20.0\nximage = 30.0\nxaperture = 60\nn_factor = 1\n\nmain(original_image,\n    \"logo.png\";\n    d_obs_screen = 230.0,\n    rel_bh_pos = 3 / 23,\n    bh_size = 1 / 15.0,\n    xaperture = 10,\n    n_factor = 3)","category":"page"},{"location":"examples/torus_kerr/#Ion-torus-in-Kerr-spacetime","page":"Ion torus around a Kerr black hole","title":"Ion torus in Kerr spacetime","text":"","category":"section"},{"location":"examples/torus_kerr/","page":"Ion torus around a Kerr black hole","title":"Ion torus around a Kerr black hole","text":"\nusing Skylight\nusing CairoMakie\n\ndistance = 500\nN = 400\nspacetime = KerrSpacetimeBoyerLindquistCoordinates(M = 1.0, a = 0.5)\ncamera = PinholeCamera(position = [0.0, distance, π * (1 / 2 - 1 / 18), 0.0],\n    horizontal_aperture_in_degrees = rad2deg(atan(20 / distance)),\n    vertical_aperture_in_degrees = rad2deg(atan(20 / distance)),\n    horizontal_number_of_pixels = N,\n    vertical_number_of_pixels = N)\nmodel = IonTorus(spacetime)\nconfigurations = NonVacuumOTEConfigurations(spacetime = spacetime,\n    camera = camera,\n    radiative_model = model,\n    unit_mass_in_solar_masses = 1.0,\n    observation_energies = exp10.(range(-10, stop = -5.5, length = 20)))\ninitial_data = initialize(configurations)\ncb, cbp = callback_setup(configurations; rhorizon_bound = 2e-1) #... or, define your own cb and cbp\nrun = integrate(initial_data,\n    configurations,\n    cb,\n    cbp;\n    method = VCABM(),\n    reltol = 1e-8,\n    abstol = 1e-8)\noutput_data = run.output_data\n\n#Image\nxs, ys = axes_ranges(camera)\nzs = grid_view(output_data, configurations; energy_index = 1)\n\nzs[zs .< 1e-40] .= 1e-40\nzs = log10.(zs)\nlogzmin = minimum(zs[zs .> -40])\nlogzmax = maximum(zs)\n\nfig = Figure(font = \"CMU Serif\") #resolution=(600,400)\nax = Axis(fig[1, 1],\n    xlabel = L\"\\alpha\",\n    ylabel = L\"\\beta\",\n    ylabelsize = 26,\n    xlabelsize = 26)\nhmap = heatmap!(xs,\n    ys,\n    zs;\n    colormap = :gist_heat,\n    interpolate = true,\n    colorrange = (logzmax - 10, logzmax))\nColorbar(fig[:, end + 1],\n    hmap,\n    label = L\"I\",\n    labelsize = 26,\n    width = 15,\n    ticksize = 18,\n    tickalign = 1)\ncolsize!(fig.layout, 1, Aspect(1, 1.0))\ncolgap!(fig.layout, 7)\nCairoMakie.save(\"torus_image.png\", fig)\n\n#Spectrum\nF = spectrum(initial_data, output_data, configurations)\nν = erg_to_Hz(configurations.observation_energies)\n\nfig = Figure()\nax = Axis(fig[1, 1],\n    xlabel = L\"\\nu \\, [\\text{Hz}]\",\n    ylabel = L\"\\nu F_{\\nu} \\,[\\text{erg} \\,\\text{s}^{-1}\\,\\text{Hz}^{-1}]\",\n    xscale = log10,\n    yscale = log10,\n    xlabelsize = 26,\n    ylabelsize = 26)\nlines!(ax, ν, ν .* Hz_to_erg(F); linewidth = 2.0, color = :blue)\nCairoMakie.save(\"torus_spectrum.png\", fig)\ndisplay(fig)\n\n#Potential\npotential = (x, z) -> Skylight.torus_normalized_potential([\n        0.0,\n        sqrt(x^2 + z^2),\n        acos(z / sqrt(x^2 + z^2)),\n        0.0,\n    ],\n    spacetime,\n    model)\n\nsize = 10\nN = 200\nx_vals = LinRange(0.0, size, N)\nz_vals = LinRange(0.0, size, N)\nw_vals = [potential(x, z) for x in x_vals, z in z_vals]\n\nw_vals[w_vals .< 0.0] .= 1e-40\nwmin = minimum(w_vals[w_vals .> 1e-40])\nwmax = maximum(w_vals)\n\nfig = Figure()\nax = Axis(fig[1, 1])\nimg = heatmap!(x_vals,\n    z_vals,\n    log10.(w_vals),\n    colormap = cmap,\n    interpolate = true,\n    colorrange = (log10(wmin), log10(wmax)))\n\ncbar = Colorbar(fig[1, 2], img, label = \"Normalized potential\", ticklabelpad = 10) \nfig","category":"page"},{"location":"radiativemodels/#Radiative-models","page":"Radiative models","title":"Radiative models","text":"","category":"section"},{"location":"radiativemodels/#Overview","page":"Radiative models","title":"Overview","text":"","category":"section"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"The radiative models are represented by types containing all the information necessary to calculate the radiation emitted by the source. The most important functions defining the radiative models are rest_frame_four_velocity!, rest_frame_bolometric_intensity, rest_frame_specific_intensity. These functions are used to compute the four velocity of the local rest frame, and the bolometric and specific intensity in that frame, respectively.","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"The following example shows how to compute these quantities for a Novikov-Thorne accretion disk in the Kerr spacetime at a given position. First, create a Kerr spacetime with mass M = 1.0 and spin a = 0.5, and obtain its coordinates topology","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"spacetime = KerrSpacetimeBoyerLindquistCoordinates(M=1.0, a=0.5)\ncoords_top = coordinates_topology(spacetime)","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Set the position at t = 0.0, r = 3.0, θ = π/2 and φ = 0.0, and calculate the metric ","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"position = [0.0, 5.0, π/2, 0.0]  #t=0.0, r = 3.0, θ = π/2, φ = 0.0\ng = zeros(4,4)\nmetric!(g, position, spacetime)","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Create a Novikov-Thorne disk with inner radius at the ISCO of the spacetime, and outer radius at 1000.0, with the unit mass assumed to be 10^7 solar masses, and the accretion rate set to 10% of the Eddington accretion rate with a radiative efficiency of 10%.","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"disk = NovikovThorneDisk(inner_radius=isco_radius(spacetime, ProgradeRotation()), \n    outer_radius = 1000.0, \n    M1 = 1e7, \n    Mdot_to_MEdd = 0.1, \n    η = 0.1)","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Compute the disk four-velocity at the position","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"u = zeros(4)\nrest_frame_four_velocity!(u, position, spacetime, disk, coords_top)","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Since the emission in the local rest frame is isotropic, we can use a random photon momentum","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"momentum = rand(4) ","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Compute the bolometric intensity and the specific intensity at an energy of 10^-4 erg in the local rest frame","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Ibol = rest_frame_bolometric_intensity(position, momentum, u, g, spacetime, disk, coords_top)\nenergy = 1e-4\nIspec = rest_frame_specific_intensity(position, momentum, energy, u, g, spacetime, disk, coords_top)","category":"page"},{"location":"radiativemodels/#Catalogue","page":"Radiative models","title":"Catalogue","text":"","category":"section"},{"location":"radiativemodels/#Geometrically-thin,-optically-thick-accretion-disks","page":"Radiative models","title":"Geometrically thin, optically thick accretion disks","text":"","category":"section"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"These accretion disk models are hydrostationary, (infinitesimally) geometrically-thin and optically thick. The disk is assumed to be in the equatorial plane of the spacetime, occupying a certain radial range. The particles of the disk are assumed to follow circular geodesics (so the circular_geodesic_angular_speed function must be implemented for the chosen spacetime).  ","category":"page"},{"location":"radiativemodels/#Thermal-radiation","page":"Radiative models","title":"Thermal radiation","text":"","category":"section"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"In these models, the disk is assumed to emit as a blackbody with a position-dependent temperature.","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Skylight.ShakuraSunyaevDisk","category":"page"},{"location":"radiativemodels/#Skylight.ShakuraSunyaevDisk","page":"Radiative models","title":"Skylight.ShakuraSunyaevDisk","text":"ShakuraSunyaevDisk <: AbstractAccretionDisk\n\nShakura & Sunyaev geometrically thin, optically thick accretion disk model.\n\nFields\n\ninner_radius::Float64: The inner of the accretion disk. Must be larger than or equal to zero.\nouter_radius::Float64: The outer radius of the accretion disk. Must be larger than or equal to inner_radius.\nM1::Float64: The unitary mass in solar masses. Must be positive.\nMdot_to_MEdd::Float64: The accretion rate in units of the Eddington accretion rate. Must be positive.\nη::Float64: The radiative efficiency of the disk, which must be in the range (0, 1].\nrotation_sense::AbstractRotationSense: The sense of rotation of the disk, which can be either ProgradeRotation() or RetrogradeRotation(). Default is ProgradeRotation().\n\nExamples\n\nspacetime = KerrSpacetimeBoyerLindquistCoordinates(M=1.0, a=0.5)\nrisco = innermost_circular_orbit_radius(spacetime, ProgradeRotation())\ndisk = ShakuraSunyaevDisk(inner_radius = risco, outer_radius=1000.0, M1=1e7, Mdot_to_MEdd=0.1, η=0.1)\n\n\n\n\n\n","category":"type"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Skylight.NovikovThorneDisk","category":"page"},{"location":"radiativemodels/#Skylight.NovikovThorneDisk","page":"Radiative models","title":"Skylight.NovikovThorneDisk","text":"NovikovThorneDisk <: AbstractAccretionDisk\n\nNovikov & Thorne geometrically thin, optically thick accretion disk model around a Schwarzschild/Kerr black hole.\n\nFields\n\ninner_radius::Float64: The inner radius of the accretion disk. Must be larger than or equal to zero.\nouter_radius::Float64: The outer radius of the accretion disk. Must be larger than or equal to inner_radius.\nM1::Float64: The unitary mass in solar masses. Must be positive.\nMdot_to_MEdd::Float64: The accretion rate in units of the Eddington accretion rate. Must be positive.\nη::Float64: The radiative efficiency of the disk, which must be in the range (0, 1].\nrotation_sense::AbstractRotationSense: The sense of rotation of the disk, which can be either ProgradeRotation() or RetrogradeRotation(). Default is ProgradeRotation().\n\nExamples\n\nspacetime = KerrSpacetimeBoyerLindquistCoordinates(M=1.0, a=0.5)\nrisco = innermost_circular_orbit_radius(spacetime, ProgradeRotation())\ndisk = NovikovThorneDisk(inner_radius = risco, outer_radius=1000.0, M1=1e7, Mdot_to_MEdd=0.1, η=0.1)\n\n\n\n\n\n","category":"type"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Skylight.AccretionDiskWithTabulatedTemperature","category":"page"},{"location":"radiativemodels/#Skylight.AccretionDiskWithTabulatedTemperature","page":"Radiative models","title":"Skylight.AccretionDiskWithTabulatedTemperature","text":"AccretionDiskWithTabulatedTemperature <: AbstractAccretionDisk\n\nGeometrically thin, optically thick axisymmetric accretion disk model with tabulated temperature.\n\nFields\n\ninner_radius::Float64: The inner of the accretion disk. Must be larger than or equal to zero.\nouter_radius::Float64: The outer radius of the accretion disk. Must be larger than or equal to inner_radius.\nrotation_sense::AbstractRotationSense: The sense of rotation of the disk, which can be either ProgradeRotation() or RetrogradeRotation(). Default is ProgradeRotation().\nfilename::String: The name of a two-column file containing the temperature profile as radius vs. temperature.\n\nExamples\n\ndisk = AccretionDiskWithTabulatedTemperature(inner_radius=6.0, outer_radius=1000.0, filename=\"temperature.txt\")\n\n\n\n\n\n","category":"type"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Skylight.RARDisk","category":"page"},{"location":"radiativemodels/#Skylight.RARDisk","page":"Radiative models","title":"Skylight.RARDisk","text":"RARDisk <: AbstractAccretionDisk\n\nRAR extension of the Shakura & Sunyaev geometrically thin, optically thick accretion disk model (Millauro et al. 2024).\n\nFields\n\ninner_radius::Float64: The inner of the accretion disk. Must be larger than or equal to zero.\nouter_radius::Float64: The outer radius of the accretion disk. Must be larger than or equal to inner_radius.\nM1::Float64: The unitary mass in solar masses. Must be positive.\nMdot_to_MEdd::Float64: The accretion rate in units of the Eddington accretion rate. Must be positive.\nη::Float64: The radiative efficiency of the disk, which must be in the range (0, 1].\nrotation_sense::AbstractRotationSense: The sense of rotation of the disk, which can be either ProgradeRotation() or RetrogradeRotation(). Default is ProgradeRotation().\n\nExamples\n\ndisk = RARDisk(inner_radius=0.0, outer_radius=1000.0, M1=1e7, Mdot_to_MEdd=0.1, η=0.1)\n\n\n\n\n\n","category":"type"},{"location":"radiativemodels/#Line-emission","page":"Radiative models","title":"Line emission","text":"","category":"section"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"In these models, the radiation corresponds to line emission from the accretion disk.","category":"page"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Skylight.AccretionDiskWithFlatLamppostProfile","category":"page"},{"location":"radiativemodels/#Skylight.AccretionDiskWithFlatLamppostProfile","page":"Radiative models","title":"Skylight.AccretionDiskWithFlatLamppostProfile","text":"AccretionDiskWithFlatLamppostProfile <: AbstractAccretionDisk\n\nGeometrically thin, optically thick accretion disk model with lamppost corona line emissivity profile as in flat spacetime:\n\nepsilon propto frach(r^2+h^2)^32\n\nwhere h is the height of the corona above the disk plane.\n\nFields\n\ninner_radius::Float64: The inner of the accretion disk. Must be larger than or equal to zero.\nouter_radius::Float64: The outer radius of the accretion disk. Must be larger than or equal to inner_radius.\nrotation_sense::AbstractRotationSense: The sense of rotation of the disk, which can be either ProgradeRotation() or RetrogradeRotation(). Default is ProgradeRotation().\ncorona_height::String: The height of the corona above the disk plane.\n\nExamples\n\ndisk = AccretionDiskWithFlatLamppostProfile(inner_radius=6.0, outer_radius=1000.0, corona_height=5.0)\n\n\n\n\n\n","category":"type"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Skylight.AccretionDiskWithTabulatedProfile","category":"page"},{"location":"radiativemodels/#Skylight.AccretionDiskWithTabulatedProfile","page":"Radiative models","title":"Skylight.AccretionDiskWithTabulatedProfile","text":"AccretionDiskWithTabulatedProfile <: AbstractAccretionDisk\n\nGeometrically thin, optically thick axisymmetric accretion disk model with tabulated line emission radial profile. This is useful, for example, for incorporating the emissivity profiles calculated using a corona model as LamppostCorona.\n\nFields\n\ninner_radius::Float64: The inner of the accretion disk. Must be larger than or equal to zero.\nouter_radius::Float64: The outer radius of the accretion disk. Must be larger than or equal to inner_radius.\nrotation_sense::AbstractRotationSense: The sense of rotation of the disk, which can be either ProgradeRotation() or RetrogradeRotation(). Default is ProgradeRotation().\nfilename::String: The name of a two-column file containing the line emission radial profile as radius vs. profile.\n\nExamples\n\ndisk = AccretionDiskWithTabulatedProfile(inner_radius=6.0, outer_radius=1000.0, filename=\"emissivity.txt\")\n\n\n\n\n\n","category":"type"},{"location":"radiativemodels/#Geometrically-thick,-optically-thin-accretion-disks","page":"Radiative models","title":"Geometrically thick, optically thin accretion disks","text":"","category":"section"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Skylight.IonTorus","category":"page"},{"location":"radiativemodels/#Skylight.IonTorus","page":"Radiative models","title":"Skylight.IonTorus","text":"IonTorus <: AbstractRadiativeModel\n\nGeometrically thick, optically thin ion torus model with synchrotron and bremsstahlung emission (Straub et al. 2012).\n\nFields\n\nλ::Float64: Specific angular momentum dimensionless parameter\nϵc::Float64: Central energy density in CGS\nn::Float64: Polytropic index\nTec::Float64: Central electron temperature in Kelvin\nξ::Float64: Electron to proton temperature ratio at the center\nβ::Float64: Equipartition factor\nH_abundance::Float64: Hydrogen abundance\nHe_abundance::Float64: Helium abundance\nrotation_sense::R: Sense of rotation of the torus, which can be either ProgradeRotation() or RetrogradeRotation()\nradiative_process::P: Radiative process, which can be either Bremsstrahlung(), Synchrotron() or SynchrotronAndBremsstrahlung()\n\nConstructor\n\nspacetime = KerrSpacetimeBoyerLindquistCoordinates(M = 1.0, a = 0.7)\nIonTorus = IonTorus(spacetime; \n    λ = 0.3, \n    ϵc = 1e-17, \n    n = 3 / 2, \n    Tec = 2e9, \n    ξ = 0.1, \n    β = 0.1, \n    H_abundance = 0.75, \n    He_abundance = 0.25, \n    rotation_sense = ProgradeRotation(), \n    radiative_process = Bremsstrahlung())\n\nNote\n\nSynchrotron self-absorption is not implemented yet.\n\n\n\n\n\n","category":"type"},{"location":"radiativemodels/#Others","page":"Radiative models","title":"Others","text":"","category":"section"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Skylight.CircularHotSpot","category":"page"},{"location":"radiativemodels/#Skylight.CircularHotSpot","page":"Radiative models","title":"Skylight.CircularHotSpot","text":"CircularHotSpot <: AbstractSurfaceEmissionModel\n\nCircular hot spot on the surface of a neutron star as in Bogdanov et al. (2019).\n\nFields\n\nstar_radius_in_km::Float64: The radius of the star in km. Must be positive.\nspin_frequency_in_Hz::Float64: The spin frequency of the star in Hz. Must be non-zero.\ncenter_colatitude_in_degrees::Float64: The colatitude of the spot center in degrees. Must be in the range [0, 90].\nangular_radius_in_radians::Float64: The angular radius of the polar cap, in radians. Must be positive.\ntemperature_in_keV::Float64: The temperature of the polar cap. Must be positive.\n\nExamples\n\nhot_spot = CircularHotSpot(\n    star_radius_in_km = 12.0,\n    spin_frequency_in_Hz = 200,\n    center_colatitude_in_degrees = 30.0,\n    angular_radius_in_radians = 1.0,\n    temperature_in_keV = 0.35\n    M1 = 1.4\n)\n\n\n\n\n\n","category":"type"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Skylight.LamppostCorona","category":"page"},{"location":"radiativemodels/#Skylight.LamppostCorona","page":"Radiative models","title":"Skylight.LamppostCorona","text":"LamppostCorona <: AbstractCorona\n\nLamppost corona model as described in Dauser et al. (2013).\n\nFields\n\nheight::Float64: The height of the lamppost corona. \nspectral_index::Float64: The spectral index of the power-law photon emission. Default is 2.0.\ntheta_offset::Float64: The offset of the lamppost corona in the polar angle. Default is 1e-8. Must be small but nonzero to avoid the coordinate singularity at the polar axis.\n\nExamples\n\ncorona = LamppostCorona(height=2.5, spectral_index = 2.0)\n\n\n\n\n\n","category":"type"},{"location":"radiativemodels/","page":"Radiative models","title":"Radiative models","text":"Skylight.StarAcrossWormhole","category":"page"},{"location":"radiativemodels/#Skylight.StarAcrossWormhole","page":"Radiative models","title":"Skylight.StarAcrossWormhole","text":"StarAcrossWormhole <: AbstractSurfaceEmissionModel\n\nUniform temperature star accross a traversable wormhole (ChargedWormholeSpacetimeRegularCoordinates).\n\nFields\n\nl_center::Float64: The center of the star in the regular radial coordinate. \nstar_radius::Float64: The radius of the star.\n\nExamples\n\nstar = StarAcrossWormhole(l_center=5.0, star_radius=1.0)\n\n\n\n\n\n","category":"type"},{"location":"initialization/initialization/#Initialization","page":"Initialization","title":"Initialization","text":"","category":"section"},{"location":"examples/frkerr/#Thin-accretion-disk-arond-f(R)-Kerr-black-hole","page":"f(R)-Kerr black hole","title":"Thin accretion disk arond f(R)-Kerr black hole","text":"","category":"section"},{"location":"examples/frkerr/","page":"f(R)-Kerr black hole","title":"f(R)-Kerr black hole","text":"using Skylight\nusing CairoMakie\n\nspacetime = FRKerrSpacetime(M = 1.0, a = 0.99, R0 = -0.0012)\n\ndistance = 750\ncamera = PinholeCamera(position = [0.0, distance, π / 2 - π / 20, 0.0],\n    horizontal_aperture_in_degrees = rad2deg(315 / distance),\n    vertical_aperture_in_degrees = rad2deg(315 / distance),\n    horizontal_number_of_pixels = 100,\n    vertical_number_of_pixels = 100)\nmodel = NovikovThorneDisk(inner_radius = 6.0, outer_radius = 18.0)\n\nconfigurations = VacuumOTEConfigurations(spacetime = spacetime,\n    camera = camera,\n    radiative_model = model,\n    unit_mass_in_solar_masses = 1.0)\n\ninitial_data = initialize(configurations)\n\ncb, cbp = callback_setup(configurations; rhorizon_bound = 2e-1) #... or, define your own cb and cbp\n\nrun = integrate(initial_data,\n    configurations,\n    cb,\n    cbp;\n    method = VCABM(),\n    reltol = 1e-13,\n    abstol = 1e-21)\n\noutput_data = run.output_data\n\nIobs = observed_bolometric_intensities(initial_data, output_data, configurations)\n\nxs, ys = axes_ranges(camera)\n\nzs = grid_view(Iobs, configurations)\n\nfig = Figure(font = \"CMU Serif\")\nax = Axis(fig[1, 1],\n    xlabel = L\"\\alpha\",\n    ylabel = L\"\\beta\",\n    ylabelsize = 26,\n    xlabelsize = 26)\nhmap = heatmap!(xs, ys, zs / maximum(zs); colormap = :gist_heat, interpolate = true)\nColorbar(fig[:, end + 1],\n    hmap,\n    label = L\"I\",\n    labelsize = 26,\n    width = 15,\n    ticksize = 18,\n    tickalign = 1)\ncolsize!(fig.layout, 1, Aspect(1, 1.0))\ncolgap!(fig.layout, 7)","category":"page"},{"location":"spacetimes/#Spacetimes","page":"Spacetimes","title":"Spacetimes","text":"","category":"section"},{"location":"spacetimes/#Overview","page":"Spacetimes","title":"Overview","text":"","category":"section"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"The spacetimes are represented by types that contain the information needed to compute geodesics and other geometric properties. Most spacetimes have parameters (for example, mass and spin) that are set at construction time. The most important function defining the spacetimes is metric, which returns the metric tensor at a given position in the spacetime. Additionally, metric_inverse returns the inverse metric tensor, volume_element returns the volume element, and christoffel returns the Christoffel symbols. Other functions are available to compute the radius of a position, the event horizon radius, the innermost stable circular orbit (ISCO) radius, the marginally bound circular orbit (MBCO) radius, and the circular geodesic angular speed, when applicable. See the API for more details.","category":"page"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"As an example, the following code snippet shows how to compute the metric tensor and the Christoffel symbols at a given position in the Schwarzschild spacetime in spherical coordinates:","category":"page"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"using Skylight\n\n# Define the Schwarzschild spacetime with mass M = 1\nspacetime = SchwarzschildSpacetimeSphericalCoordinates(M=1.0)\nposition = [0.0, 4.0, π/2, 0.0]  #t=0.0, r = 4.0, θ = π/2, φ = 0.0\ng = metric(position, spacetime)\nΓ = christoffel(position, spacetime)","category":"page"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"The previous example uses the metric and christoffel functions, which allocate the output arrays each time they are called. However, when these functions need to be called within tight loops, we suggest using the non-allocating methods metric! and christoffel!. These functions use preallocated arrays and auxiliary caches to store the results and intermediate variables. The caches can be constructed with the allocate_cache and allocate_christoffel_cache functions, respectively.","category":"page"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"g = zeros(4, 4)\ncache = allocate_cache(spacetime)\nmetric!(g, position, spacetime, cache)\nΓ = zeros(4, 4, 4)\nchristoffel_cache = allocate_christoffel_cache(spacetime)\nchristoffel!(Γ, position, spacetime, christoffel_cache)","category":"page"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"Some spacetimes are sufficiently simple that they do not require caches to store intermediate results, either in the calculation of the metric, the Christoffel symbols or both. In these cases, the cache constructors just return nothing, and the cache can be omitted as an argument in the non-allocating methods. These methods are still more efficient than the allocating ones, as they avoid allocating the output arrays.","category":"page"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"metric!(g, position, spacetime)\nchristoffel!(Γ, position, spacetime)","category":"page"},{"location":"spacetimes/#Catalogue","page":"Spacetimes","title":"Catalogue","text":"","category":"section"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"The following are the currently implemented spacetimes:","category":"page"},{"location":"spacetimes/#Minkowski-spacetime","page":"Spacetimes","title":"Minkowski spacetime","text":"","category":"section"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"Modules = [Skylight]\nFilter = t -> typeof(t) === DataType && t <: Skylight.AbstractMinkowskiSpacetime && isconcretetype(t)","category":"page"},{"location":"spacetimes/#Skylight.MinkowskiSpacetimeCartesianCoordinates","page":"Spacetimes","title":"Skylight.MinkowskiSpacetimeCartesianCoordinates","text":"MinkowskiSpacetimeCartesianCoordinates <: AbstractMinkowskiSpacetime\n\nMinkowski Spacetime in spherical coordinates. \n\nds^2 = -dt^2 + dx^2 + dy^2 + dz^2\n\nConstructor\n\nMinkowskiSpacetimeCartesianCoordinates()\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Skylight.MinkowskiSpacetimeSphericalCoordinates","page":"Spacetimes","title":"Skylight.MinkowskiSpacetimeSphericalCoordinates","text":"MinkowskiSpacetimeSphericalCoordinates <: AbstractMinkowskiSpacetime\n\nMinkowski Spacetime in spherical coordinates. \n\nds^2 = -dt^2 + dr^2 + r^2 dtheta^2 + r^2 sin^2 theta dphi^2\n\nwhere r is the radial coordinate and θ is the polar angle.\n\nConstructor\n\nMinkowskiSpacetimeSphericalCoordinates()\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Schwarzschild-spacetime","page":"Spacetimes","title":"Schwarzschild spacetime","text":"","category":"section"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"Modules = [Skylight]\nFilter = t -> typeof(t) === DataType && t <: Skylight.AbstractSchwarzschildSpacetime && isconcretetype(t)","category":"page"},{"location":"spacetimes/#Skylight.SchwarzschildSpacetimeKerrSchildCoordinates","page":"Spacetimes","title":"Skylight.SchwarzschildSpacetimeKerrSchildCoordinates","text":"SchwarzschildSpacetimeKerrSchildCoordinates <: AbstractSchwarzschildSpacetime\n\nSchwarzschild spacetime in Kerr-Schild coordinates. The parameter M is the mass. The metric is\n\ng_mu nu = eta_mu nu + H l_mu l_nu\n\nwhere eta_mu nu is the flat metric, H=2Mr, and l_mu=(1xyz)r.\n\nConstructor\n\nSchwarzschildSpacetimeKerrSchildCoordinates(M=1.0)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Skylight.SchwarzschildSpacetimeSphericalCoordinates","page":"Spacetimes","title":"Skylight.SchwarzschildSpacetimeSphericalCoordinates","text":"SchwarzschildSpacetimeSphericalCoordinates <: AbstractSchwarzschildSpacetime\n\nSchwarzschild spacetime in spherical coordinates. The metric is\n\nds^2 = -(1-2Mr) dt^2 + (1-2Mr)^-1 dr^2 + r^2 dtheta^2 + r^2 sin^2 theta dphi^2\n\nConstructor\n\nSchwarzschildSpacetimeSphericalCoordinates(M=1.0)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Kerr-spacetime","page":"Spacetimes","title":"Kerr spacetime","text":"","category":"section"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"Modules = [Skylight]\nFilter = t -> typeof(t) === DataType && t <: Skylight.AbstractKerrSpacetime && isconcretetype(t)","category":"page"},{"location":"spacetimes/#Skylight.KerrSpacetimeBoyerLindquistCoordinates","page":"Spacetimes","title":"Skylight.KerrSpacetimeBoyerLindquistCoordinates","text":"KerrSpacetimeBoyerLindquistCoordinates <: AbstractKerrSpacetime\n\nKerr spacetime in Boyer-Lindquist coordinates. The parameter are the mass M and the  dimensionless spin a. \n\nConstructor\n\nKerrSpacetimeBoyerLindquistCoordinates(M=1.0, a=0.99)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Skylight.KerrSpacetimeKerrSchildCoordinates","page":"Spacetimes","title":"Skylight.KerrSpacetimeKerrSchildCoordinates","text":"KerrSpacetimeKerrSchildCoordinates <: AbstractKerrSpacetime\n\nKerr spacetime in Kerr-Schild coordinates. The parameter are the mass M and the  dimensionless spin a. The metric is\n\ng_mu nu = eta_mu nu + H l_mu l_nu\n\nwhere eta_mu nu is the flat metric, H=2Mr^3(r^4+a^2 z^2, and \n\nl_mu=(1fracrx+ayr^2+a^2fracry-axr^2+a^2zr)\n\nwhere r satisfies the equation\n\nfracx^2+y^2r^2+a^2 + fracz^2r^2 = 1\n\nConstructor\n\nKerrSpacetimeKerrSchildCoordinates(M=1.0, a=0.99)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Johannsen-spacetime","page":"Spacetimes","title":"Johannsen spacetime","text":"","category":"section"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"Skylight.JohannsenSpacetime","category":"page"},{"location":"spacetimes/#Skylight.JohannsenSpacetime","page":"Spacetimes","title":"Skylight.JohannsenSpacetime","text":"JohannsenSpacetime <: AbstractBlackHoleSpacetime\n\nJohannsen spacetime to lowest order in the  deformation parameters with respect to the Kerr metric\n\nConstructor\n\nJohannsenSpacetime(M=1.0, a=0.99, α13=0.5, α22=0.0, α52=0.01, ϵ3=0.0)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#f(R)-Kerr-spacetime","page":"Spacetimes","title":"f(R)-Kerr spacetime","text":"","category":"section"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"Skylight.FRKerrSpacetime","category":"page"},{"location":"spacetimes/#Skylight.FRKerrSpacetime","page":"Spacetimes","title":"Skylight.FRKerrSpacetime","text":"FRKerrSpacetime <: AbstractBlackHoleSpacetime\n\nf(R)-Kerr spacetime  (uncharged) with constant curvature R_0\n\nConstructor\n\nFRKerrSpacetime(M=1.0, a=0.99, R0=-0.0012) \n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Charged-wormhole-spacetime","page":"Spacetimes","title":"Charged wormhole spacetime","text":"","category":"section"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"Modules = [Skylight]\nFilter = t -> typeof(t) === DataType && t <: Skylight.AbstractChargedWormholeSpacetime && isconcretetype(t)","category":"page"},{"location":"spacetimes/#Skylight.ChargedWormholeSpacetimeRegularCoordinates","page":"Spacetimes","title":"Skylight.ChargedWormholeSpacetimeRegularCoordinates","text":"ChargedWormholeSpacetimeRegularCoordinates <: AbstractChargedWormholeSpacetime\n\nCharged wormhole spacetime  in regular (throat crossing) coordinates.\n\nConstructor\n\nChargedWormholeSpacetimeRegularCoordinates(b0=1.0, Q=0.5)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Skylight.ChargedWormholeSpacetimeSphericalCoordinates","page":"Spacetimes","title":"Skylight.ChargedWormholeSpacetimeSphericalCoordinates","text":"ChargedWormholeSpacetimeSphericalCoordinates <: AbstractChargedWormholeSpacetime\n\nCharged wormhole spacetime  in usual spherical coordinates.\n\nConstructor\n\nChargedWormholeSpacetimeSphericalCoordinates(b0=1.0, Q=0.5)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#RAR-spacetime","page":"Spacetimes","title":"RAR spacetime","text":"","category":"section"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"Skylight.RARSpacetime","category":"page"},{"location":"spacetimes/#Skylight.RARSpacetime","page":"Spacetimes","title":"Skylight.RARSpacetime","text":"RARSpacetime <: AbstractRegularCompactObjectSpacetime\n\nSpacetimes for Ruffini-Arguelles-Rueda dark matter distributions. The spacetime is constructed by interpolating given data files. The numerical data must include the g_tt, g_rr, partial_r nu, M(r) and partial_r M as two-column (r-value) files named gtt.txt, grr.txt, dnu.txt, M.txt and dM.txt, respectively. Here nu = log(-g_tt), notice that dnudr can be extracted directly from the right-hand side of the RAR equilibrium equations, to avoid unnecessary numerical errors. \n\nThe data must be in geometrized units.\n\nConstructor\n\nRARSpacetime(\"./rar_data\")\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Boson-star-spacetime","page":"Spacetimes","title":"Boson star spacetime","text":"","category":"section"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"Skylight.BosonStarSpacetime","category":"page"},{"location":"spacetimes/#Skylight.BosonStarSpacetime","page":"Spacetimes","title":"Skylight.BosonStarSpacetime","text":"BosonStarSpacetime <: AbstractRegularCompactObjectSpacetime\n\nBoson star spacetime in spherical coordinates. It uses analyical fits. Either the  fit parameters can be provided as vectors, or any of the symbols :LBS1,  :LBS2, :LBS3, :SBS1, :SBS2 or :SBS3 as constructor arguments\n\nConstructors\n\nBosonStarSpacetime(a=aparams, b=bparams) \nBosonStarSpacetime(:LBS1)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Coordinates-topology","page":"Spacetimes","title":"Coordinates topology","text":"","category":"section"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"The spacetimes in Skylight are defined in different coordinate systems, which are arbitrary. However, most coordinates used in practice have either Cartesian or spherical topology. For instance, Boyer–Lindquist coordinates for Kerr spacetime have spherical topology, whereas Kerr-Schild Cartesian coordinates have Cartesian topology. The coordinates_topology function returns the topology of the coordinates of a given spacetime. The following are the currently implemented coordinate topologies:","category":"page"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"Skylight.CartesianTopology\nSkylight.SphericalTopology","category":"page"},{"location":"spacetimes/#Skylight.CartesianTopology","page":"Spacetimes","title":"Skylight.CartesianTopology","text":"CartesianTopology <: AbstractCoordinatesTopology\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Skylight.SphericalTopology","page":"Spacetimes","title":"Skylight.SphericalTopology","text":"SphericalTopology <: AbstractCoordinatesTopology\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Abstract-types","page":"Spacetimes","title":"Abstract types","text":"","category":"section"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"The spacetimes in Skylight are organized in a hierarchy of types that leverage Julia's type system and multiple dispatch to define common behaviors. All Skylight spacetimes are subtypes of the abstract type AbstractSpacetime. For example, the abstract type AbstractBlackHoleSpacetime is a subtype of AbstractSpacetime and is used to define spacetimes that have an event horizon. This common feature among all black hole spacetimes is used, for example, to define a common callback for all of them which prevents geodesic integration too close to an event horizon, avoiding numerical instabilities. In turn, the abstract type AbstractKerrSpacetime represents a Kerr spacetime and has the various concrete Kerr spacetimes, in different coordinate systems, as subtypes. For reference, the following are the abstract spacetime types defined in Skylight: ","category":"page"},{"location":"spacetimes/","page":"Spacetimes","title":"Spacetimes","text":"Skylight.AbstractSpacetime\nSkylight.AbstractBlackHoleSpacetime\nSkylight.AbstractRegularCompactObjectSpacetime\nSkylight.AbstractMinkowskiSpacetime\nSkylight.AbstractSchwarzschildSpacetime\nSkylight.AbstractKerrSpacetime\nSkylight.AbstractChargedWormholeSpacetime","category":"page"},{"location":"spacetimes/#Skylight.AbstractSpacetime","page":"Spacetimes","title":"Skylight.AbstractSpacetime","text":"AbstractSpacetime\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Skylight.AbstractBlackHoleSpacetime","page":"Spacetimes","title":"Skylight.AbstractBlackHoleSpacetime","text":"AbstractBlackHoleSpacetime <: AbstractSpacetime\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Skylight.AbstractRegularCompactObjectSpacetime","page":"Spacetimes","title":"Skylight.AbstractRegularCompactObjectSpacetime","text":"AbstractRegularCompactObjectSpacetime <: AbstractSpacetime\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Skylight.AbstractMinkowskiSpacetime","page":"Spacetimes","title":"Skylight.AbstractMinkowskiSpacetime","text":"AbstractMinkowskiSpacetime <: AbstractSpacetime\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Skylight.AbstractSchwarzschildSpacetime","page":"Spacetimes","title":"Skylight.AbstractSchwarzschildSpacetime","text":"AbstractSchwarzschildSpacetime <: AbstractBlackHoleSpacetime\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Skylight.AbstractKerrSpacetime","page":"Spacetimes","title":"Skylight.AbstractKerrSpacetime","text":"AbstractKerrSpacetime <: AbstractBlackHoleSpacetime\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/#Skylight.AbstractChargedWormholeSpacetime","page":"Spacetimes","title":"Skylight.AbstractChargedWormholeSpacetime","text":"AbstractChargedWormholeSpacetime <: AbstractSpacetime\n\n\n\n\n\n","category":"type"},{"location":"othertypes/#Abstract-types-and-traits","page":"-","title":"Abstract types and traits","text":"","category":"section"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"gettingstarted/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"gettingstarted/#1.-Set-up-your-environment","page":"Getting started","title":"1. Set up your environment","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"After you have installed the package following the instructions in the homepage, start a Julia REPL with multithreading optionally enabled as ","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"julia -t NT","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"where NT is the number of threads you want to use. Then, load the package as","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"using Skylight","category":"page"},{"location":"gettingstarted/#2.-Create-a-spacetime","page":"Getting started","title":"2. Create a spacetime","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"Here, we create a Kerr spacetime in Boyer-Lindquist coordinates: ","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"spacetime = KerrSpacetimeBoyerLindquistCoordinates(M=1.0,a=0.5)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"Find other available spacetimes at Spacetimes. ","category":"page"},{"location":"gettingstarted/#3.-Create-a-radiative-model","page":"Getting started","title":"3. Create a radiative model","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"Here we create a Novikov-Thorne disk in prograde rotation around the black hole, specifying the inner and outer radii of the disk. The inner radius is set to the innermost stable circular orbit (ISCO) of the black hole, which depends on the spacetime parameters and rotation direction.","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"disk = NovikovThorneDisk(inner_radius=isco_radius(spacetime, ProgradeRotation()), outer_radius = 15.0)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"Other available radiative models can be found at Radiative models. ","category":"page"},{"location":"gettingstarted/#4.-Set-up-a-camera","page":"Getting started","title":"4. Set up a camera","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"Then, we create a pinhole camera, where the position is given by the spacetime coordinates of the observation point, the aperture is determined by the horizontal and vertical aperture in degrees, and the number of pixels in each direction are given. Here the apertures are set to capture a wide view of the accretion disk. For more details on the camera setup, see Pinhole camera. ","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"camera = PinholeCamera(position = [0.0, 500, π/2-π/20, 0.0],\n                        horizontal_aperture_in_degrees = rad2deg(80/500),\n                        vertical_aperture_in_degrees = rad2deg(80/500),\n                        horizontal_number_of_pixels = 600,\n                        vertical_number_of_pixels = 600)","category":"page"},{"location":"gettingstarted/#5.-Set-up-the-configurations-object","page":"Getting started","title":"5. Set up the configurations object","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"We gather the spacetime, radiative model, and camera into a configurations object. This setup is for a vacuum transport problem (in the observer-to-emitter method).","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"configurations = VacuumOTEConfigurations(spacetime=spacetime,\n                                        radiative_model=disk,\n                                        camera = camera,\n                                        unit_mass_in_solar_masses = 1e7)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"where unit_mass_in_solar_masses is the unit mass in solar masses which, together with c=G=1, fully determines your units system. This latter choice will affect the interpretation of the varius quantities set before as, e.g. the mass of the Kerr spacetime, which now is understood to correspond to 10^7 solar masses.","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"For more general non-vacuum transfer problems, use ","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"configurations = NonVacuumOTEConfigurations(spacetime = spacetime,\n    camera = camera,\n    radiative_model = model,\n    unit_mass_in_solar_masses = 1e7,\n    observation_energies = exp10.(range(-10, stop = -5.5, length = 20)))","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"where observation_energies is a vector of the observation energies in CGS units. ","category":"page"},{"location":"gettingstarted/#6.-Generate-the-initial-data","page":"Getting started","title":"6. Generate the initial data","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"Create the initial data for the transport problem with","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"initial_data = initialize(configurations)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"The initial data will be a matrix having the initial conditions for each observation direction as columns, with the first four components being the spacetime coordinates (the same as the camera position), and the last four components are the components of the initial momentum in the corresponding coordinate frame. ","category":"page"},{"location":"gettingstarted/#7.-Define-callbacks","page":"Getting started","title":"7. Define callbacks","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"We define a callback to be called at each step of the equations integration. This is generally used to stop the integration under certain conditions as getting far away from the source, or intersecting the emitting surface. The default callbacks can be set up with","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"cb, cbp = callback_setup(configurations; rhorizon_bound=0.1)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"where cb is the Callback object, and cbp contains the callback parameters. In this particular setup, an extra parameter has to be passed as an argument (rhorizon_bound), which determines the minimum radial distance to which rays can approximate the event horizon before terminating the integration (this is because no future-directed rays can exit the event horizon, so, conversely, no past-directed rays can enter it). ","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"Additionally, custom callbacks can be defined. For more details, see Callbacks and Event Handling. ","category":"page"},{"location":"gettingstarted/#8.-Integrate-the-equations","page":"Getting started","title":"8. Integrate the equations","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"Then, we integrate the radiative transfer and geodesic equations, choosing a solver method and setting the relative and absolute tolerances. ","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"sim = integrate(initial_data,\n    configurations,\n    cb,\n    cbp;\n    method = VCABM(),\n    reltol = 1e-8,\n    abstol = 1e-8)","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"In certain setups, you may require lower errors for the integration to remain stable, especially when dealing with interpolated spacetimes. The integrate function is a wrapper for the DifferentialEquations.jl package's solve function. As such, you can pass any additional keyword arguments that are accepted by the solve. In particular, any of the available solver methods can be used. For more information, see the DifferentialEquations.jl documentation.","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"The output data can be extracted as","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"output_data = sim.output_data","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"This matrix contains the final coordinates and momenta of each ray, with the same structure as the initial data.","category":"page"},{"location":"gettingstarted/#9.-Visualize-the-results","page":"Getting started","title":"9. Visualize the results","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"Finally, we compute, for instance, the observed bolometric intensity of the radiation field, and produce an image using CairoMakie as","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"using CairoMakie\n\nIobs = observed_bolometric_intensities(initial_data, output_data, configurations)\n\nxs, ys = axes_ranges(camera)\nzs = grid_view(Iobs, configurations)\n\nfig = Figure(font = \"CMU Serif\")\nax = Axis(fig[1, 1],\n    xlabel = L\"\\alpha \\, [\\mathrm{deg}]\",\n    ylabel = L\"\\beta \\, [\\mathrm{deg}]\",\n    ylabelsize = 26,\n    xlabelsize = 26)\nhmap = heatmap!(rad2deg.(xs), rad2deg.(ys), zs; colormap = :gist_heat, interpolate = true)\nColorbar(fig[:, end + 1],\n    hmap,\n    label = L\"I \\, [\\mathrm{erg}/\\mathrm{s}/\\mathrm{cm^2}/\\mathrm{sr}]\",\n    labelsize = 26,\n    width    = 15,\n    ticksize = 18,\n    tickalign = 1)\ncolsize!(fig.layout, 1, Aspect(1, 1.0))\ncolgap!(fig.layout, 7)\ndisplay(fig)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Spacetime","page":"API","title":"Spacetime","text":"","category":"section"},{"location":"api/#Geometric-functions","page":"API","title":"Geometric functions","text":"","category":"section"},{"location":"api/#Allocating-methods","page":"API","title":"Allocating methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"metric(position::AbstractVector, spacetime::AbstractSpacetime)\nmetric_inverse(position::AbstractVector, spacetime::AbstractSpacetime)\nvolume_element(position::AbstractVector, spacetime::AbstractSpacetime)\nchristoffel(position::AbstractVector, spacetime::AbstractSpacetime)","category":"page"},{"location":"api/#Skylight.metric-Tuple{AbstractVector, AbstractSpacetime}","page":"API","title":"Skylight.metric","text":"metric(position::AbstractVector, spacetime::AbstractSpacetime)\n\nEvaluate the spacetime metric at the given position and return the result.\n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.metric_inverse-Tuple{AbstractVector, AbstractSpacetime}","page":"API","title":"Skylight.metric_inverse","text":"metric_inverse(position::AbstractVector, spacetime::AbstractSpacetime)\n\nEvaluate the inverse of the metric at the given position and return the result.\n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.volume_element-Tuple{AbstractVector, AbstractSpacetime}","page":"API","title":"Skylight.volume_element","text":"volume_element(position::AbstractVector, spacetime::AbstractSpacetime)\n\nCompute sqrt-textdet(g) at the given position \n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.christoffel-Tuple{AbstractVector, AbstractSpacetime}","page":"API","title":"Skylight.christoffel","text":"christoffel(position::AbstractVector, spacetime::AbstractSpacetime)\n\nEvaluate the Christoffel symbols of the second kind at the given position and return the result as a 4x4x4 array  Γ, where Γ[α,μ,ν] corresponds to \n\nGamma^alpha_mu nu = frac12 g^alpha rho(partial_mu g_rho nu + partial_nu g_rho mu - partial_rho g_mu nu)\n\n\n\n\n\n","category":"method"},{"location":"api/#Non-allocating-methods","page":"API","title":"Non-allocating methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"For computing these quantities within tight loops, we suggest to use the following non-allocating methods that write the output on preallocated arrays, and use caches to store intermediate results. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"metric!(metric::AbstractMatrix, position::AbstractVector, spacetime::AbstractSpacetime, cache::Union{Nothing, AbstractSpacetimeCache})\nmetric_inverse!(metric::AbstractMatrix, position::AbstractVector, spacetime::AbstractSpacetime, g::AbstractMatrix, cache::Union{Nothing, AbstractSpacetimeCache})\nvolume_element(position::AbstractVector, spacetime::AbstractSpacetime, g::AbstractMatrix, cache::Union{Nothing, AbstractSpacetimeCache})\nchristoffel!(metric::AbstractMatrix, position::AbstractVector, spacetime::AbstractSpacetime, cache::Union{Nothing, AbstractChristoffelCache})","category":"page"},{"location":"api/#Skylight.metric!-Tuple{AbstractMatrix, AbstractVector, AbstractSpacetime, Union{Nothing, AbstractSpacetimeCache}}","page":"API","title":"Skylight.metric!","text":"metric!(g::AbstractMatrix, position::AbstractVector, spacetime::AbstractSpacetime, cache::Union{Nothing, AbstractSpacetimeCache})\n\nEvaluate the spacetime metric at the given position and store the result in g using cache for temporary storage.  \n\nThe cache should be preallocated as cache = allocate_cache(spacetime).\n\nSee also allocate_cache. \n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.metric_inverse!-Tuple{AbstractMatrix, AbstractVector, AbstractSpacetime, AbstractMatrix, Union{Nothing, AbstractSpacetimeCache}}","page":"API","title":"Skylight.metric_inverse!","text":"metric_inverse!(ginv::AbstractMatrix, position::AbstractVector, spacetime::AbstractSpacetime, g::AbstractMatrix, cache::Union{Nothing, AbstractSpacetimeCache})\n\nEvaluate the inverse of the metric at the given position  and store the result in the given array, using g and cache for temporary storage, which must be preallocated as g = zeros(4,4) and cache = allocate_cache(spacetime).\n\nSee also allocate_cache. \n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.volume_element-Tuple{AbstractVector, AbstractSpacetime, AbstractMatrix, Union{Nothing, AbstractSpacetimeCache}}","page":"API","title":"Skylight.volume_element","text":"volume_element(position::AbstractVector, spacetime::AbstractSpacetime, g::AbstractMatrix, cache::Union{Nothing, AbstractSpacetimeCache})\n\nCompute sqrt-textdet(g) at the given position, using g and cache for temporary storage, which must be preallocated as g = zeros(4,4) and cache = allocate_cache(spacetime). \n\nSee also allocate_cache. \n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.christoffel!-Tuple{AbstractMatrix, AbstractVector, AbstractSpacetime, Union{Nothing, AbstractChristoffelCache}}","page":"API","title":"Skylight.christoffel!","text":"christoffel!(Γ::AbstractArray, position::AbstractVector, spacetime::AbstractSpacetime, cache::Union{Nothing,AbstractChristoffelCache})\n\nEvaluate the Christoffel symbols of the second kind at the given position and store the result in Γ, where Γ[α,μ,ν] corresponds to \n\nGamma^alpha_mu nu = frac12 g^alpha rho(partial_mu g_rho nu + partial_nu g_rho mu - partial_rho g_mu nu)\n\nThe cache must be preallocated as cache = allocate_christoffel_cache(spacetime).\n\nSee also allocate_christoffel_cache.\n\n\n\n\n\n","category":"method"},{"location":"api/#Other-functions","page":"API","title":"Other functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"coordinates_topology(spacetime::AbstractSpacetime)\nradius(position::AbstractVector, spacetime::AbstractSpacetime)\nevent_horizon_radius(spacetime::AbstractBlackHoleSpacetime)\nisco_radius(spacetime::AbstractSpacetime, rotation_sense::AbstractRotationSense)\nmbco_radius(spacetime::AbstractSpacetime, rotation_sense::AbstractRotationSense)\ncircular_geodesic_angular_speed(position::AbstractVector, spacetime::AbstractSpacetime, rotation_sense::AbstractRotationSense)","category":"page"},{"location":"api/#Skylight.coordinates_topology-Tuple{AbstractSpacetime}","page":"API","title":"Skylight.coordinates_topology","text":"coordinates_topology(spacetime::AbstractSpacetime)\n\nReturn the topology of the coordinates of the given spacetime.\n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.radius-Tuple{AbstractVector, AbstractSpacetime}","page":"API","title":"Skylight.radius","text":"radius(position, spacetime)\n\nRadius of the given position in the given spacetime. \n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.event_horizon_radius-Tuple{AbstractBlackHoleSpacetime}","page":"API","title":"Skylight.event_horizon_radius","text":"event_horizon_radius(spacetime)\n\nRadius of the event horizon of the given spacetime. Defined only for black hole spacetimes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.isco_radius-Tuple{AbstractSpacetime, AbstractRotationSense}","page":"API","title":"Skylight.isco_radius","text":"isco_radius(spacetime, rotation_sense::AbstractRotationSense)\n\nRadius of the innermost stable circular orbit in the given spacetime and rotation sense (either Prograde() or  Retrograde()).\n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.mbco_radius-Tuple{AbstractSpacetime, AbstractRotationSense}","page":"API","title":"Skylight.mbco_radius","text":"mbco_radius(spacetime, rotation_sense::AbstractRotationSense)\n\nRadius of the marginally bound circular orbit in the given spacetime and rotation sense (either Prograde() or Retrograde()).\n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.circular_geodesic_angular_speed-Tuple{AbstractVector, AbstractSpacetime, AbstractRotationSense}","page":"API","title":"Skylight.circular_geodesic_angular_speed","text":"circular_geodesic_angular_speed(position, spacetime, rotation_sense::AbstractRotationSense)\n\nAngular speed of a circular geodesic at the given positioninspacetime`for a particle rotating in the givenrotation_sense`.\n\n\n\n\n\n","category":"method"},{"location":"api/#Cache-allocation","page":"API","title":"Cache allocation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"allocate_cache(spacetime::AbstractSpacetime)\nallocate_christoffel_cache(spacetime::AbstractSpacetime)","category":"page"},{"location":"api/#Skylight.allocate_cache-Tuple{AbstractSpacetime}","page":"API","title":"Skylight.allocate_cache","text":"allocate_cache(spacetime::AbstractSpacetime)\n\nAllocate a cache object for the given spacetime. The cache object is used to store temporary data in spacetime-related calculations.\n\nSee also metric!. \n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.allocate_christoffel_cache-Tuple{AbstractSpacetime}","page":"API","title":"Skylight.allocate_christoffel_cache","text":"allocate_christoffel_cache(spacetime::AbstractSpacetime)\n\nAllocate a cache object for Christoffel symbols calculations.\n\nSee also christoffel!. \n\n\n\n\n\n","category":"method"},{"location":"api/#Radiative-model","page":"API","title":"Radiative model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"    rest_frame_four_velocity!(vector::AbstractVector, position::AbstractVector, metric::AbstractMatrix, spacetime::AbstractSpacetime, model::AbstractRadiativeModel, coords_top::AbstractCoordinatesTopology, spacetime_cache::AbstractSpacetimeCache, model_cache::AbstractModelCache)\n    rest_frame_bolometric_intensity(position::AbstractVector, momentum::AbstractVector, rest_frame_four_velocity::AbstractVector, metric::AbstractMatrix, spacetime::AbstractSpacetime, model::AbstractRadiativeModel, coords_top::AbstractCoordinatesTopology, cache::AbstractModelCache)\n    rest_frame_specific_intensity(position::AbstractVector, momentum::AbstractVector, energy::Real, rest_frame_four_velocity::AbstractVector, metric::AbstractMatrix, spacetime::AbstractSpacetime, model::AbstractRadiativeModel, coords_top::AbstractCoordinatesTopology, cache::AbstractModelCache)\n    is_final_position_at_source(position::AbstractVector, sapcetime::AbstractSpacetime, model::AbstractRadiativeModel)\n    lorentz_factors(positions, spacetime::AbstractSpacetime, model::AbstractRadiativeModel)\n    allocate_cache(model::AbstractRadiativeModel)","category":"page"},{"location":"api/#Skylight.rest_frame_four_velocity!-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractSpacetime, AbstractRadiativeModel, AbstractCoordinatesTopology, AbstractSpacetimeCache, AbstractModelCache}","page":"API","title":"Skylight.rest_frame_four_velocity!","text":"rest_frame_four_velocity!(vector::AbstractVector, position::AbstractVector, metric::AbstractMatrix, spacetime::AbstractSpacetime, model::AbstractRadiativeModel, coords_top::AbstractCoordinatesTopology, spacetime_cache::AbstractSpacetimeCache, model_cache::AbstractModelCache)\n\nRest frame four velocity of the model at given `position`. This is the frame where the model radiative functions are defined.\n\nArguments\n\nvector: Output vector.\nposition: Position where the four-velocity is evaluated.\nmetric: Metric tensor at position.\nspacetime: Spacetime.\nmodel: Radiative model.\ncoords_top: Coordinates topology.\nspacetime_cache: Spacetime cache.\nmodel_cache: Model cache.\n\nSee also\n\nallocate_cache(model::AbstractRadiativeModel)\n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.rest_frame_bolometric_intensity-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractMatrix, AbstractSpacetime, AbstractRadiativeModel, AbstractCoordinatesTopology, AbstractModelCache}","page":"API","title":"Skylight.rest_frame_bolometric_intensity","text":"rest_frame_bolometric_intensity(position::AbstractVector, momentum::AbstractVector, rest_frame_four_velocity::AbstractVector, metric::AbstractMatrix, spacetime::AbstractSpacetime, model::AbstractRadiativeModel, coords_top::AbstractCoordinatesTopology, cache::AbstractModelCache)\n\nBolometric intensity of the model at given `position`.\n\nArguments\n\nposition: Position where the intensity is evaluated.\nmomentum: Momentum of the emission (frequency and direction).\nrest_frame_four_velocity: Rest frame four velocity of the model at position. Must but be normalized.\nmetric: Metric tensor at position.\nspacetime: Spacetime.\nmodel: Radiative model.\ncoords_top: Coordinates topology.\ncache: Model cache.\n\nSee also\n\nallocate_cache(model::AbstractRadiativeModel)\n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.rest_frame_specific_intensity-Tuple{AbstractVector, AbstractVector, Real, AbstractVector, AbstractMatrix, AbstractSpacetime, AbstractRadiativeModel, AbstractCoordinatesTopology, AbstractModelCache}","page":"API","title":"Skylight.rest_frame_specific_intensity","text":"rest_frame_specific_intensity(position::AbstractVector, momentum::AbstractVector, energy::Real, rest_frame_four_velocity::AbstractVector, metric::AbstractMatrix, spacetime::AbstractSpacetime, model::AbstractRadiativeModel, coords_top::AbstractCoordinatesTopology, cache::AbstractModelCache)\n\nSpecific intensity of the model at given `position`.\n\nArguments\n\nposition: Position where the intensity is evaluated.\nmomentum: Momentum of the emission (frequency and direction).\nenergy: Energy of the emission. This should be assumed to be in CGS units.\nrest_frame_four_velocity: Rest frame four velocity of the model at position. Must but be normalized.\nmetric: Metric tensor at position.\nspacetime: Spacetime.\nmodel: Radiative model.\ncoords_top: Coordinates topology.\ncache: Model cache.\n\nSee also\n\nallocate_cache(model::AbstractRadiativeModel)\n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.is_final_position_at_source-Tuple{AbstractVector, AbstractSpacetime, AbstractRadiativeModel}","page":"API","title":"Skylight.is_final_position_at_source","text":"is_final_position_at_source(position::AbstractVector, spacetime::AbstractSpacetime, model::AbstractRadiativeModel)\n\nCheck if the final position of the photon is at the source of the model. This function is used in the observer-to-emitter method\nin vacuum to discard rays that do not intersect the source.\n\nArguments\n\nposition: Final position of the geodesic.\nspacetime: Spacetime.\nmodel: Radiative model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.lorentz_factors-Tuple{Any, AbstractSpacetime, AbstractRadiativeModel}","page":"API","title":"Skylight.lorentz_factors","text":"lorentz_factors(positions, spacetime::AbstractSpacetime, model::AbstractRadiativeModel)\n\nLorentz factors of the rest frame four velocities of `model` at given list of positions. Positions should be an iterable\nobject with the positions as elements.\n\n# Returns\n\nAn array with the Lorentz factors of the rest frame four velocities of the model at the given positions.\n\n# Example\n\n```\npositions = [[0.0, 5.0, 0.0, 0.0], [1.0, 0.0, 5.0, 0.0]]\nspacetime = SchwarzschildSpacetimeSphericalCoordinates(M=1.0)\nmodel = DummyModel()\nγ = lorentz_factors(positions, spacetime, model)\n```\n\n\n\n\n\n","category":"method"},{"location":"api/#Skylight.allocate_cache-Tuple{AbstractRadiativeModel}","page":"API","title":"Skylight.allocate_cache","text":"allocate_cache(model::AbstractRadiativeModel)\n\nAllocate a cache object for the given model. The cache object is used to store temporary data in radiative-model-related calculations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Surface-emission-models","page":"API","title":"Surface emission models","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"surface_differential!(differential::AbstractVector, position::AbstractVector, model::AbstractSurfaceEmissionModel, coords_top::AbstractCoordinatesTopology)","category":"page"},{"location":"api/#Skylight.surface_differential!-Tuple{AbstractVector, AbstractVector, AbstractSurfaceEmissionModel, AbstractCoordinatesTopology}","page":"API","title":"Skylight.surface_differential!","text":"surface_differential!(differential::AbstractVector, position::AbstractVector, model::AbstractSurfaceEmissionModel, coords_top::AbstractCoordinatesTopology)\n\nDifferential of the function defining the emitting surface in the model. For example, for an emitting sphere in Cartesian coordinates, the output would be `[0,2x,2y,2z]`.\nThe normalization of the differential is not important, as it is only used to calculate the surface (unit) normal in terms of the metric.\n\nArguments\n\ndifferential: Output vector.\nposition: Position where the differential is evaluated.\nmodel: Radiative model.\ncoords_top: Coordinates topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#Thermal-emission-models","page":"API","title":"Thermal emission models","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"temperature(position::AbstractVector, spacetime::AbstractSpacetime, model::AbstractRadiativeModel)","category":"page"},{"location":"api/#Skylight.temperature-Tuple{AbstractVector, AbstractSpacetime, AbstractRadiativeModel}","page":"API","title":"Skylight.temperature","text":"temperature(position::AbstractVector, spacetime::AbstractSpacetime, model::AbstractRadiativeModel)\n\nTemperature of the model at given `position`.\n\n\n\n\n\n","category":"method"},{"location":"api/#Line-emission-models","page":"API","title":"Line emission models","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"line_emission_profile(position::AbstractVector, momentum::AbstractVector, rest_frame_four_velocity::AbstractVector, metric::AbstractMatrix, spacetime::AbstractSpacetime, model::AbstractRadiativeModel, coords_top::AbstractCoordinatesTopology, cache::AbstractModelCache)","category":"page"},{"location":"api/#Skylight.line_emission_profile-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractMatrix, AbstractSpacetime, AbstractRadiativeModel, AbstractCoordinatesTopology, AbstractModelCache}","page":"API","title":"Skylight.line_emission_profile","text":"line_emission_profile(position::AbstractVector, momentum::AbstractVector, rest_frame_four_velocity::AbstractVector, metric::AbstractMatrix, spacetime::AbstractSpacetime, model::AbstractRadiativeModel, coords_top::AbstractCoordinatesTopology, cache::AbstractModelCache)\n\nEmissivity profile for line emission radiative models.\n\nArguments\n\nposition: Position of the emission.\nmomentum: Momentum of the emission (frequency and direction). Must be null.\nrest_frame_four_velocity: Rest frame four velocity of the model at position. Must but be normalized.\nmetric: Metric tensor at position.\nspacetime: Spacetime.\nmodel: Radiative model.\ncoords_top: Coordinates topology.\ncache: Model cache.\n\nSee also\n\nallocate_cache(model::AbstractRadiativeModel)\n\n\n\n\n\n","category":"method"},{"location":"configurations/configurations/#Configurations","page":"Configurations","title":"Configurations","text":"","category":"section"},{"location":"miscellanea/misc/#Miscellanea","page":"Miscellanea","title":"Miscellanea","text":"","category":"section"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"In the observer-to-emitter method the initial momenta are past-directed and pointing inwards. To see why this is valid cosider the following: the Lioville vector field on the tangent bundle of spacetime is the vector field which generates the geodesic flow. The component of this field along the fibers is invariant to sign inversion on the fiber. This means that the geodesic passing through the point (x^μk^μ) and the one passing through (x^μ-k^μ) project to the same curve on the base spacetime. We do it this way so the geodesic integrator kernel is common to both transport methods. Otherwise, although the physical equations would be the same, the numerical integrators would have to be different because we would have to take backward steps in the observer-to-emitter case. Once we have the solutions, we can invert the sign of k^μ if necessary when we use it elsewhere. ","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"ispositionat_source should't be used in condition/affect. Its purpose is to classify the endstate of a geodesic already stopped, not to condition the geodesic integration.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Callback params needs to have an rmax.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Coordinates are assumed to be have either cartesian or spherical topology, and to be ordered like (t r theta varphi) or (t x y z). The first coordinate is assumed to be temporal, and the other three spatial. This is checked for in the initialization via the metric signature.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"AbstractAccretionDisk assumes innerradius and outerradius as fields.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"The integrator can integrate geodesics of any kind (timelike and spacelike too)","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Custom initial data can be provided as well to the integrator as an array of size (8 N) where N is the number of rays.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"The intensity integrated in non-vacuum is the invariant intensity","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"The emissivity must take vectors of energies as inputs","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Setting the absorptovity function to return nothing is equivalent to setting the absorptivity to zero","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"The non-vacuum transfer equations only work towards the past because of rest frame energy sign assumption. This will be generalized.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Observation energies in non-vacuum are assumed to be in CGS.","category":"page"},{"location":"miscellanea/porting_from_c/#Tips-for-porting-a-metric-from-C","page":"Tips for porting a metric from C","title":"Tips for porting a metric from C","text":"","category":"section"},{"location":"miscellanea/porting_from_c/","page":"Tips for porting a metric from C","title":"Tips for porting a metric from C","text":"Change function to metric! and arguments to g, position, spacetime\nExtract t,x,y,z = position\nRemove all variable declarations\nRemove all remaining double\nRemove all ; (be careful there are no two or more commands in one line)\nReplace all // by  (checkout for C macros before)\nReplace result[i] by resulti\nUse regular expressions to replace pow(base, exp) as follows: 8.1. Find pow(([^,]),\\s([^)]+)) using Reg Ex 8.2. Replace by (1)^(2) \nReplace gcov by g (just for consistency)\nReplace return\" by return nothing\"\nRemove all unused variables \nIn case of keeping arrays, shift indexes because Julia is 1-based (whereas C is 0-based)  To do this you can search for the regular expression (\\w+)[\\s(\\d+)\\s] and replace by 12+1]  After that you can search all (1+1) and replace by 2 and so on.  In case there is [][] or other type of indexing you need to generalize the RegEx\nRemove final } and add end\nReplace ++ by +=1\nReplace integers that are used in ifs and whiles by booleans (or minimally you can change by e.g. while(keep_iterating==1)) and then replace keep_iterating=1 by keep_iterating=true and keep_iterating=0 by keep_iterating=false","category":"page"},{"location":"miscellanea/utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"radiativetransfer/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"initialization/pinholecamera/#Pinhole-camera","page":"Pinhole camera","title":"Pinhole camera","text":"","category":"section"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"The energy momentum tensor of the radiation field in terms of the specific intensity is given by","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^ab = int k^a k^b left( fracI_nunu^3 right) dV_k ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where dV_k = nu dnu dOmega. Equivalently,","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^a b = int_S^2 int_0^infty n^a n^b I_nu dnu dOmega ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where n^a = k^a  nu. The radiative flux of energy in the direction of barn^a measured by an osberver with four-velocity u^a is T^a b u_a barn_b.","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"For discretizing this integral at position x^mu, we choose an orthonormal tetrad. We take","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"e_0 = partial_t \ne_1 = -partial_r \ne_2 = partial_phi \ne_3 = -partial_theta ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"and orthonormalize it with respect to g_alpha beta(x^mu), where (rtheta phi) are some topolgically spherical coordinates on the spacetime. Note that this assumes there is a timelike coordinate t and three spacelike coordinates from which there is a meaningful way of transforming to spherical-like coordinates. In flat spacetime, the interpretation of this tetrad is simple: e_1 points towards the origin, e_2 is in the azimuthal direction, and e_3 is in the polar direction. Note that the triad we use is not direct. Note also that the choice of tetrad does not actually matter. The procedure we choose is sufficiently general to allow (almost) arbitrary spacetime position, flux direction, and observer four-velocity, but it is particularly well suited for large distances in asymptotically flat spacetimes where the source can be covered by a small spherical sector centered around e_1. Finally, we take coordinates (alpha beta) on S^2 such that ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"alpha = varphi \nbeta = pi2 -vartheta","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where (vartheta varphi) are the usual angular coordinates on S^2. The coordinates range over -π le alpha lt pi and -pi2 le beta le pi2. The tetrad components of a vector in these coordinates can be written as","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"k^0 = nu  \nk^1 = nu cos alpha cos beta \nk^2 = nu sin alpha cos beta \nk^3 = nu sin beta ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Thus, in particular (alpha beta) = (00) maps to e_1. In these coordinates, dOmega = cos beta dalpha dbeta. We only need to take the (alpha beta) coordinate ranges large enough to cover the image of the emitting source. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Finally, we approximate the integral numerically as","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"sum_i j k I_ijk n^a_ij n^b_ij Delta Omega_ij Delta nu      ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where I_ijk = I_nu_k(n^a_ij), the tetrad components of n^a_ij are ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"1 cos alpha_i cos beta_j sin alpha_i cos beta_j sin beta_j ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"(we have to transform them to the coordinate frame before contraction), the solid angle of each section is","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Delta Omega_ij = int_D_ij cos beta dalpha dbeta = 2 cos(beta_j) sin left(fracDelta beta2 right) Delta alpha","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"and D_ij = alpha_i-Delta alpha2 alpha_i+Delta alpha2 times beta_j - Delta beta  2 beta_j + Delta beta 2. We took a uniform grid such that ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"alpha_i = -s_alpha2+(i-12)Delta alpha  \nbeta_j = -s_beta2+(j-12)Delta beta \nDelta alpha = s_alphaN_alpha \nDelta beta = s_betaN_beta \n1 le i le N_alpha  \n1 le j le N_beta","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where s_alpha s_beta are the horizontal and vertical aperture angles respectively, and N_alpha, N_beta are the numbers of pixels. The total solid angle is Delta Omega = 2 sin(s_beta2)s_alpha","category":"page"},{"location":"#Skylight.jl","page":"Home","title":"Skylight.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(The documentation is under construction...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Skylight.jl is a Julia package for general-relativistic ray-tracing and radiative transfer in curved spacetimes. It works with any spacetime geometry, without the constraints of specific symmetries or the assumption of asymptotic flatness. It is designed with the following goals in mind:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fast computational speed\nHigh accuracy\nEasy extensibility to user-defined spacetimes and radiative models","category":"page"},{"location":"","page":"Home","title":"Home","text":"It uses automatic differentiation from ForwardDiff.jl to compute the Christoffel symbols from the spacetime metric, and has built-in multithreading parallelism. At its core, Skylight simultaneously solves the geodesic equations and the covariant transport equations along the geodesics, i.e.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracmathopd^2 x^alphamathopdlambda^2+Gamma^alpha_mu nu fracmathopd x^mumathopdlambda fracmathopd x^numathopdlambda=0 ","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Gamma^alpha_mu nu are the Christoffel symbols of the spacetime, x^alpha is the position and lambda is an affine parameter along the geodesic, together with","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracmathopdmathopdlambda left( fracI_nunu^3right) = fracj_nunu^2 - nu alpha_nu left( fracI_nunu^3right) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"where nu is the frequency, I_nu is the intensity of the radiation field, and j_nu and alpha_nu are the emissivity and absorptivity coefficients of the medium, respectively. Skylight has a special treatment for surface emission models with transport in vacuum, like geometrically-thin accretion disks, where the transport can be reduced to the connection of the intensity of the radiation field between the emission and observation points using a Lorentz and geodesic invariant I_nu  nu^3. The inegration of the equations is performed with DifferentialEquations.jl. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a quick start guide, see Getting started. Here is the full API (both the start guide and the API are under construction). Find the source code here. ","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#Supported-spacetimes","page":"Home","title":"Supported spacetimes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minkowski spacetime\nSchwarzschild spacetime\nKerr spacetime\nJohannsen spacetime\nf(R)-Kerr spacetime\nRuffini-Argüelles-Rueda spacetime for fermionic dark matter\nBoson star spacetimes with quartic self-interaction and solitonic potentials  \nExtensibility to user-defined spacetimes","category":"page"},{"location":"#Supported-radiative-models","page":"Home","title":"Supported radiative models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Shakura-Sunyaev accretion disk\nNovikov-Thorne accretion disk\nIon tori with synchrotron and bremsstrahlung emission \nGeometrically-thin optically-thick accretion disks with user-provided tabulated temperatures\nLine emission from accretion disks with user-provided emissivity profiles\nLamppost corona emission and accretion disk illumination profiles\nCircular hot spots on the surface of a neutron star\nExtensibility to user-defined radiative models","category":"page"},{"location":"#Geometric-and-dynamical-tools","page":"Home","title":"Geometric and dynamical tools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spacetime metrics, inverse metrics, volume elements, Christoffel symbols, etc.\nFour-vector scalar products, index raising/lowering, orthogonal projection, normalization, etc.\nConstants of motion in spacetimes with symmetries\nCharacteristic radii, like event horizons, ISCOs, and MBCOs. \nSpacetime geodesics integration","category":"page"},{"location":"#Radiative-transfer","page":"Home","title":"Radiative transfer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Radiative transfer in vacuum and in emissive/absorptive media","category":"page"},{"location":"#Observable-quantities","page":"Home","title":"Observable quantities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bolometric and specific intensities\nFluxes through arbitrarily oriented surface elements\nImages and spectra\nGeneric observation frames (any position and four-velocity)","category":"page"},{"location":"#Utilities","page":"Home","title":"Utilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Loading/saving data and configurations from/to HDF5 files\nUnits and dimensions management","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia version at least 1.6","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is not yet available in the Julia registries. To install it, follow these steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Clone the repository: git clone https://github.com/joaquinpelle/Skylight.jl.git\nOpen the Julia REPL and enter package mode by typing ].\nAdd Skylight to your Pkg environment: ] dev \\path\\to\\the\\repository\nImport Skylight: using Skylight","category":"page"},{"location":"#Folder-contents","page":"Home","title":"Folder contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":".\n├── docs                    # Documentation files\n├── run                     # Example scripts and notebooks to run the code\n├── src                     # Source files\n├── test                    # Test files \n│   ├── benchmarks          # Load and stress tests\n│   ├── integration         # End-to-end, integration tests\n│   └── unit                # Unit tests","category":"page"},{"location":"#To-run-the-unit-tests","page":"Home","title":"To run the unit tests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In your terminal, go to the package directory \nOpen the Julia REPL\nGo to the package mode by typing ]\nActivate the package environment by running the command activate .\nIn the package mode, run the command test","category":"page"},{"location":"#To-cite-this-work","page":"Home","title":"To cite this work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this software in your work, we kindly request that you cite the following paper","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{pelle2022skylight,\n  title={Skylight: a new code for general-relativistic ray-tracing and radiative transfer in arbitrary space--times},\n  author={Pelle, Joaquin and Reula, Oscar and Carrasco, Federico and Bederian, Carlos},\n  journal={Monthly Notices of the Royal Astronomical Society},\n  volume={515},\n  number={1},\n  pages={1316--1327},\n  year={2022},\n  publisher={Oxford University Press}\n}","category":"page"},{"location":"citing/#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citing/","page":"Citing","title":"Citing","text":"If you use this software in your work, we kindly request that you cite the following paper","category":"page"},{"location":"citing/","page":"Citing","title":"Citing","text":"@article{pelle2022skylight,\n  title={Skylight: a new code for general-relativistic ray-tracing and radiative transfer in arbitrary space--times},\n  author={Pelle, Joaquin and Reula, Oscar and Carrasco, Federico and Bederian, Carlos},\n  journal={Monthly Notices of the Royal Astronomical Society},\n  volume={515},\n  number={1},\n  pages={1316--1327},\n  year={2022},\n  publisher={Oxford University Press}\n}","category":"page"}]
}
