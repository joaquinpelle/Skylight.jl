var documenterSearchIndex = {"docs":
[{"location":"postprocess/postprocess/#Postprocess","page":"Postprocess","title":"Postprocess","text":"","category":"section"},{"location":"spacetimes/catalogue/#Catalogue-of-spacetimes","page":"Catalogue","title":"Catalogue of spacetimes","text":"","category":"section"},{"location":"spacetimes/catalogue/","page":"Catalogue","title":"Catalogue","text":"Modules = [Skylight]\nFilter = t -> typeof(t) === DataType && t <: Skylight.AbstractSpacetime && isconcretetype(t)","category":"page"},{"location":"spacetimes/catalogue/#Skylight.BosonStarSpacetime","page":"Catalogue","title":"Skylight.BosonStarSpacetime","text":"BosonStarSpacetime <: AbstractRegularCompactObjectSpacetime\n\nBoson star spacetime in spherical coordinates. It uses analyical fits. Either the  fit parameters as described in... can be provided as vectors, or any of the symbols :LBS1,  :LBS2, :LBS3, :SBS1, :SBS2 or :SBS3 as constructor arguments\n\nConstructors\n\nBosonStarSpacetime(a=aparams, a=9, R0=-0.0012) \nBosonStarSpacetime(:LBS1)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.ChargedWormholeSpacetimeRegularCoordinates","page":"Catalogue","title":"Skylight.ChargedWormholeSpacetimeRegularCoordinates","text":"ChargedWormholeSpacetimeRegularCoordinates <: AbstractSpacetime\n\nCharged wormhole spacetime  in regular (throat crossing) coordinates.\n\nConstructor\n\nChargedWormholeSpacetimeRegularCoordinates(b0=1.0, Q=0.5)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.ChargedWormholeSpacetimeSphericalCoordinates","page":"Catalogue","title":"Skylight.ChargedWormholeSpacetimeSphericalCoordinates","text":"ChargedWormholeSpacetimeSphericalCoordinates <: AbstractSpacetime\n\nCharged wormhole spacetime  in usual spherical coordinates.\n\nConstructor\n\nChargedWormholeSpacetimeSphericalCoordinates(b0=1.0, Q=0.5)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.FRKerrSpacetime","page":"Catalogue","title":"Skylight.FRKerrSpacetime","text":"FRKerrSpacetime <: AbstractBlackHoleSpacetime\n\nf(R)-Kerr spacetime  (uncharged) with constant curvature R_0\n\nConstructor\n\nFRKerrSpacetime(M=1.0, a=0.99, R0=-0.0012) \n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.JohannsenSpacetime","page":"Catalogue","title":"Skylight.JohannsenSpacetime","text":"JohannsenSpacetime <: AbstractBlackHoleSpacetime\n\nJohannsen spacetime to lowest order in the  deformation parameters with respect to the Kerr metric\n\nConstructor\n\nJohannsenSpacetime(M=1.0, a=0.99, α13=0.5, α22=0.0, α52=0.01, ϵ3=0.0)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.KerrSpacetimeBoyerLindquistCoordinates","page":"Catalogue","title":"Skylight.KerrSpacetimeBoyerLindquistCoordinates","text":"KerrSpacetimeBoyerLindquistCoordinates <: AbstractKerrSpacetime\n\nKerr spacetime in Boyer-Lindquist coordinates. The parameter are the mass M and the  dimensionless spin a. \n\nConstructor\n\nKerrSpacetimeBoyerLindquistCoordinates(M=1.0, a=0.99)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.KerrSpacetimeKerrSchildCoordinates","page":"Catalogue","title":"Skylight.KerrSpacetimeKerrSchildCoordinates","text":"KerrSpacetimeKerrSchildCoordinates <: AbstractKerrSpacetime\n\nKerr spacetime in Kerr-Schild coordinates. The parameter are the mass M and the  dimensionless spin a. The metric is\n\ng_mu nu = eta_mu nu + H l_mu l_nu\n\nwhere eta_mu nu is the flat metric, H=2Mr^3(r^4+a^2 z^2, and \n\nl_mu=(1fracrx+ayr^2+a^2fracry-axr^2+a^2zr)\n\nwhere r satisfies the equation\n\nfracx^2+y^2r^2+a^2 + fracz^2r^2 = 1\n\nConstructor\n\nKerrSpacetimeKerrSchildCoordinates(M=1.0, a=0.99)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.MinkowskiSpacetimeCartesianCoordinates","page":"Catalogue","title":"Skylight.MinkowskiSpacetimeCartesianCoordinates","text":"MinkowskiSpacetimeCartesianCoordinates <: AbstractSpacetime\n\nMinkowski Spacetime in spherical coordinates. \n\nds^2 = -dt^2 + dx^2 + dy^2 + dz^2\n\nConstructor\n\nMinkowskiSpacetimeCartesianCoordinates()\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.MinkowskiSpacetimeSphericalCoordinates","page":"Catalogue","title":"Skylight.MinkowskiSpacetimeSphericalCoordinates","text":"MinkowskiSpacetimeSphericalCoordinates <: AbstractSpacetime\n\nMinkowski Spacetime in spherical coordinates. \n\nds^2 = -dt^2 + dr^2 + r^2 dtheta^2 + r^2 sin^2 theta dphi^2\n\nwhere r is the radial coordinate and θ is the polar angle.\n\nConstructor\n\nMinkowskiSpacetimeSphericalCoordinates()\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.SchwarzschildSpacetimeKerrSchildCoordinates","page":"Catalogue","title":"Skylight.SchwarzschildSpacetimeKerrSchildCoordinates","text":"SchwarzschildSpacetimeKerrSchildCoordinates <: AbstractSchwarzschildSpacetime\n\nSchwarzschild spacetime in Kerr-Schild coordinates. The parameter M is the mass. The metric is\n\ng_mu nu = eta_mu nu + H l_mu l_nu\n\nwhere eta_mu nu is the flat metric, H=2Mr, and l_mu=(1xyz)r.\n\nConstructor\n\nSchwarzschildSpacetimeKerrSchildCoordinates(M=1.0)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/#Skylight.SchwarzschildSpacetimeSphericalCoordinates","page":"Catalogue","title":"Skylight.SchwarzschildSpacetimeSphericalCoordinates","text":"SchwarzschildSpacetimeSphericalCoordinates <: AbstractSchwarzschildSpacetime\n\nSchwarzschild spacetime in spherical coordinates. The metric is\n\nds^2 = -(1-2Mr) dt^2 + (1-2Mr)^-1 dr^2 + r^2 dtheta^2 + r^2 sin^2 theta dphi^2\n\nConstructor\n\nSchwarzschildSpacetimeSphericalCoordinates(M=1.0)\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/catalogue/","page":"Catalogue","title":"Catalogue","text":"Skylight.RARSpacetime","category":"page"},{"location":"spacetimes/catalogue/#Skylight.RARSpacetime","page":"Catalogue","title":"Skylight.RARSpacetime","text":"RARSpacetime <: AbstractRegularCompactObjectSpacetime\n\nRuffini-Arguelles-Rueda spacetime for dark-matter galactic core-halo. The spacetime is constructed by interpolating the data files in a given directory. The numerical data must include the r, g_tt, g_rr, partial_r nu, M(r) and partial_r M as columns in that order. The data must be in geometrized  units.\n\nConstructor\n\nRARSpacetime(\"./rar_data\")\n\n\n\n\n\n","category":"type"},{"location":"publications/#Publications","page":"Publications","title":"Publications","text":"","category":"section"},{"location":"publications/","page":"Publications","title":"Publications","text":"This software has been utilized for the following publications:","category":"page"},{"location":"publications/","page":"Publications","title":"Publications","text":"Neto, M. R., Perez, D., & Pelle, J. (2023). The shadow of charged traversable wormholes. International Journal of Modern Physics D, 32(02), 2250137.\nCarrasco, F., Pelle, J., Reula, O., Viganò, D., & Palenzuela, C. (2023). Relativistic force-free models of the thermal X-ray emission in millisecond pulsars observed by NICER. Monthly Notices of the Royal Astronomical Society, 520(2), 3151-3163.\nPelle, J., Reula, O., Carrasco, F., & Bederian, C. (2022). Skylight: a new code for general-relativistic ray-tracing and radiative transfer in arbitrary space–times. Monthly Notices of the Royal Astronomical Society, 515(1), 1316-1327.","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"radiativetransfer/radiativetransfer/#Radiative-transfer","page":"Radiative transfer","title":"Radiative transfer","text":"","category":"section"},{"location":"radiativemodels/radiativeprocesses/#Radiative-processes","page":"Radiative processes","title":"Radiative processes","text":"","category":"section"},{"location":"spacetimes/othertypes/#Other-types","page":"Other types","title":"Other types","text":"","category":"section"},{"location":"spacetimes/othertypes/","page":"Other types","title":"Other types","text":"Modules = [Skylight]\nPages = [\"spacetimes/types.jl\"]\nFilter = t -> typeof(t) === DataType ","category":"page"},{"location":"spacetimes/othertypes/#Skylight.AbstractBlackHoleSpacetime","page":"Other types","title":"Skylight.AbstractBlackHoleSpacetime","text":"AbstractBlackHoleSpacetime <: AbstractSpacetime\n\nSupertype for representing spacetimes containing black holes. \n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.AbstractChristoffelCache","page":"Other types","title":"Skylight.AbstractChristoffelCache","text":"AbstractSpacetimeCache\n\nAbstract type for cache objects to be used as temporary storage in Christoffel symbol calculations.\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.AbstractCoordinatesTopology","page":"Other types","title":"Skylight.AbstractCoordinatesTopology","text":"AbstractCoordinatesTopology\n\nAbstract type for representing the topology of the coordinates of a spacetime.\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.AbstractRegularCompactObjectSpacetime","page":"Other types","title":"Skylight.AbstractRegularCompactObjectSpacetime","text":"AbstractRegularCompactObjectSpacetime <: AbstractSpacetime\n\nSupertype for representing spacetimes containing compact objects without horizons like boson stars. \n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.AbstractRotationSense","page":"Other types","title":"Skylight.AbstractRotationSense","text":"AbstractRotationSense\n\nAbstract type for representing the rotation sense of a circular orbit in a spacetime.\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.AbstractSpacetime","page":"Other types","title":"Skylight.AbstractSpacetime","text":"AbstractSpacetime\n\nSupertype for representing the geometrical structure of spacetime. Specific implementations of spacetime, such as black holes and regular compact objects, are subtypes of this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.AbstractSpacetimeCache","page":"Other types","title":"Skylight.AbstractSpacetimeCache","text":"AbstractSpacetimeCache\n\nAbstract type for caching spacetime-related computations. This can be used as scratch memory in calculations involving the spacetime.\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.CartesianTopology","page":"Other types","title":"Skylight.CartesianTopology","text":"CartesianTopology <: AbstractCoordinatesTopology\n\nCartesian coordinates topology.\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.ProgradeRotation","page":"Other types","title":"Skylight.ProgradeRotation","text":"ProgradeRotation <: AbstractRotationSense\n\nPrograde rotation sense for a circular orbit in a spacetime.\n\nConstructor\n\nProgradeRotation()\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.RetrogradeRotation","page":"Other types","title":"Skylight.RetrogradeRotation","text":"RetrogradeRotation <: AbstractRotationSense\n\nRetrograde rotation sense for a circular orbit in a spacetime.\n\nConstructor\n\nRetrogradeRotation()\n\n\n\n\n\n","category":"type"},{"location":"spacetimes/othertypes/#Skylight.SphericalTopology","page":"Other types","title":"Skylight.SphericalTopology","text":"SphericalTopology <: AbstractCoordinatesTopology\n\nSpherical coordinates topology.\n\n\n\n\n\n","category":"type"},{"location":"initialization/initialization/#Initialization","page":"Initial data","title":"Initialization","text":"","category":"section"},{"location":"radiativemodels/radiativemodels/#Radiative-models","page":"Radiative models","title":"Radiative models","text":"","category":"section"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"configurations/configurations/#Configurations","page":"Configurations","title":"Configurations","text":"","category":"section"},{"location":"miscellanea/misc/#Miscellanea","page":"Miscellanea","title":"Miscellanea","text":"","category":"section"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"In the observer-to-emitter scheme the initial momenta are past-directed and pointing inwards. This is valid because of the following reason. The Lioville vector field on the tangent bundle is the vector field which generates the geodesic flow. The component of this field along the fibers is invariant to sign inversion on the fiber. This means that the geodesic passing through the point (x^μk^μ) and the one passing through (x^μ-k^μ) project to the same curve on the base spacetime. We do it this way so the geodesic integrator kernel is common to both transport schemes. Otherwise, although the physical equations would be the same, the numerical integrators would be different because we would have to take backward steps in the observer-to-emitter case. Once we have the solutions, we invert the sign of k^μ when we use it elsewhere.  ispositionat_source should't be used in condition/affect. Its purpose is to classify the endstate of a geodesic already integrated, not to condition the geodesic integration.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Currently Christoffels assume the input array is filled with zeros","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Callback params needs to have an rmax. Fix or make explicit.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Coordinates are assumed to be have either cartesian or spherical topology, and to be ordered like t, r, θ, φ or t, x, y, z. The first coordinate is assumed to be timelike, and the other three spatial.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"AbstractAccretionDisk assumes innerradius and outerradius as fields.","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"The procedure is modularized sufficiently so that custom initial data can be provided as well to the integrator (as a (8, nrays) array)","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"The integrator can integrate geodesics of any kind (timelike and spacelike too)","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"You need invariant emissivity to work for vectors of energies Setting absorptovity function to nothing is equivalent to setting absorptivity to zero","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"The intensity integrated in non-vacuum is the invariant intensity","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"The non-vacuum transfer equations only work towards the past because of rest frame energy sign assumption","category":"page"},{"location":"miscellanea/misc/","page":"Miscellanea","title":"Miscellanea","text":"Observation energies in non-vacuum need to be their CGS values","category":"page"},{"location":"miscellanea/porting_from_c/#Tips-for-porting-a-metric-from-C","page":"Tips for porting a metric from C","title":"Tips for porting a metric from C","text":"","category":"section"},{"location":"miscellanea/porting_from_c/","page":"Tips for porting a metric from C","title":"Tips for porting a metric from C","text":"Change function to metric! and arguments to g, position, spacetime\nExtract t,x,y,z = position\nRemove all variable declarations\nRemove all remaining double\nRemove all ; (be careful there are no two or more commands in one line)\nReplace all // by  (checkout for C macros before)\nReplace result[i] by resulti\nUse regular expressions to replace pow(base, exp) as follows: 8.1. Find pow(([^,]),\\s([^)]+)) using Reg Ex 8.2. Replace by (1)^(2) \nReplace gcov by g (just for consistency)\nReplace return\" by return nothing\"\nRemove all unused variables \nIn case of keeping arrays, shift indexes because Julia is 1-based (whereas C is 0-based)  To do this you can search for the regular expression (\\w+)[\\s(\\d+)\\s] and replace by 12+1]  After that you can search all (1+1) and replace by 2 and so on.  In case there is [][] or other type of indexing you need to generalize the RegEx\nRemove final } and add end\nReplace ++ by +=1\nReplace integers that are used in ifs and whiles by booleans (or minimally you can change by e.g. while(keep_iterating==1)) and then replace keep_iterating=1 by keep_iterating=true and keep_iterating=0 by keep_iterating=false","category":"page"},{"location":"spacetimes/functions/","page":"Functions","title":"Functions","text":"Modules = [Skylight]\nOrder = [:function]","category":"page"},{"location":"spacetimes/functions/#Skylight.allocate_cache-Tuple{AbstractSpacetime}","page":"Functions","title":"Skylight.allocate_cache","text":"allocate_cache(spacetime)\n\nAllocate a cache object for the given spacetime. The cache object is used to store temporary data in spacetime-related calculations.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.allocate_christoffel_cache-Tuple{AbstractSpacetime}","page":"Functions","title":"Skylight.allocate_christoffel_cache","text":"allocate_christoffel_cache(spacetime)\n\nAllocate a cache object for the Christoffel symbols calculation. Unless a more specific method is defined, an instance of Skylight.AutoDiffChristoffelCache is returned.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.approximate_gradient_norm-Tuple{Array, Real, Real}","page":"Functions","title":"Skylight.approximate_gradient_norm","text":"approximate_gradient_norm(z::Array, dx_spacing::Real, dy_spacing::Real)\n\nCompute the norm of the gradient of a function given a 2D grid of function values z and grid spacings dx_spacing and dy_spacing.\n\nThe gradient is computed using central differences in the interior and forward or backward differences at the edges.\n\nArguments\n\nz::Array: 2D grid of function values.\ndx_spacing::Real: Grid spacing in the x direction.\ndy_spacing::Real: Grid spacing in the y direction.\n\nReturns\n\ngrad_norm::Array: 2D grid of gradient magnitudes.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.average_inside_bins-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.average_inside_bins","text":"average_inside_bins(q, x, bins)\n\nCalculate the averages of a quantity q at value x in each bin defined by bins.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.axial_symmetry-Tuple{AbstractSpacetime}","page":"Functions","title":"Skylight.axial_symmetry","text":"axial_symmetry(spacetime)\n\nReturn IsAxiallySymmetric() if the spacetime is axially symmetric, IsNotAxiallySymmetric() otherwise.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.bin_values_and_sum_weights-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.bin_values_and_sum_weights","text":"bin_values_and_sum_weights(bins, values, weights)\n\nBin values and sum weights in each bin.\n\nArguments\n\nbins: Array of bin edges.\nvalues: Array of values to be binned.\nweights: Array of weights to be summed in each bin.\n\nReturns\n\nbinned_values: Array of the sum of weights in each bin.\n\nNotes\n\nThe length of values and weights must be the same.\nValues outside the range of bins are ignored.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.christoffel!-Tuple{Any, Any, AbstractSpacetime, Nothing}","page":"Functions","title":"Skylight.christoffel!","text":"christoffel!(Γ, position, spacetime, cache)\n\nEvaluate the Christoffel symbols at the given position and store the result in the given array using cache for temporary storage. Unless a more specific method is defined, automatic differentiation is used to compute the Christoffel symbols.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.christoffel!-Tuple{Any, Any, AbstractSpacetime, Skylight.AutoDiffChristoffelCache}","page":"Functions","title":"Skylight.christoffel!","text":"\" Calculates the Christoffel symbols of a given spacetime metric using the forward-mode automatic differentiation package ForwardDiff.\n\nArguments:\n\nΓ₂: mutable array of size (4,4,4) to store the resulting Christoffel symbols.\nposition: tuple of four numbers representing a position in spacetime.\nspacetime: object representing the spacetime.\ncache: object of type AutoDiffChristoffelCache with containers for metric elements and derivatives.\n\nReturns: nothing.\n\nNote: for the automatic differentiation to work on a given spacetime, any spacetime cache array used in  metric calculations must be wrapped by the DiffCache() method as:\n\n```\n@with_kw mutable struct KerrSpacetimeCache{T} <: AbstractSpacetimeCache\n    l::T = DiffCache(zeros(4))\nend\n```\n\nThis is because automatic differentiation keeps two versions of each variable, a Real and a Dual version, the latter being used to compute derivatives at each node of the chain rule. Also, in the metric!(g, position, spacetime) function, the caches must be accessed via the function get_tmp as in get_tmp(spacetime.l, position), so that the appropriate version of the cache is returned according to the element type of position when metric! is called.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.circular_geodesic_angular_speed-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.circular_geodesic_angular_speed","text":"circular_geodesic_angular_speed(position, spacetime, rotation_sense::AbstractRotationSense)\n\nAngular speed of a circular geodesic at the given position in the given spacetime for a particle rotating in the given sense.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.circular_geodesic_energy-Tuple{Any, FRKerrSpacetime, AbstractRotationSense}","page":"Functions","title":"Skylight.circular_geodesic_energy","text":"Set for M=1\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.circular_geodesic_specific_angular_momentum-Tuple{Any, FRKerrSpacetime, AbstractRotationSense}","page":"Functions","title":"Skylight.circular_geodesic_specific_angular_momentum","text":"Set for M=1\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.compose_N_times-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.compose_N_times","text":"compose_N_times(N, f, x)\n\nCompose function f to the input x for N times.\n\nArguments\n\nN: The number of times to apply the function f.\nf: The function to be applied.\nx: The input to the function f.\n\nExample\n\nmatrix = rand(Bool, 5, 5)\ncompose_N_times(3, detect_edges, matrix)\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.cos_angle_between_null_vectors-NTuple{4, Any}","page":"Functions","title":"Skylight.cos_angle_between_null_vectors","text":"The cosine of the angle between null vectors v and w as seen by observer at normalized four-velocity u\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.cos_angle_between_vectors-NTuple{4, Any}","page":"Functions","title":"Skylight.cos_angle_between_vectors","text":"The cosine of the angle between vectors v and w as seen by observer at normalized four-velocity\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.det2x2sym-Tuple{Any}","page":"Functions","title":"Skylight.det2x2sym","text":"Computes the determinant of a 2x2 symmetric matrix using a closed-form formula.\n\nArguments:\n\nmatrix: array of size (2,2) containing the input symmetric matrix.\n\nReturns: the determinant of the input matrix.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.det4x4sym-Tuple{Any}","page":"Functions","title":"Skylight.det4x4sym","text":"Computes the determinant of a 4x4 symmetric matrix using a closed-form formula.\n\nArguments:\n\nmatrix: array of size (4,4) containing the input symmetric matrix.\n\nReturns: the determinant of the input matrix.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.detect_edges-Tuple{Int64, Union{BitMatrix, Matrix{Bool}}}","page":"Functions","title":"Skylight.detect_edges","text":"detect_edges(N, arr)\n\nDetects values that are at distance at most N from an edge. Composes detect_edges to  the input arr for 1 to N times, and combines the results using an elementwise OR operation.  Each application of detect_edges is performed on the result of the previous application and the results are combined in succession.\n\nArguments\n\nN::Int: The maximum number of times to apply the function f.\narr::Union{Matrix{Bool}, BitMatrix}: The boolean array.\n\nExample\n\njulia matrix = rand(Bool, 5, 5) detect_edges(3, matrix)` In this example, the detect_edges function is applied 1 to 3 times to a 5x5 random Boolean matrix, and the results are combined with an OR operation.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.detect_edges-Tuple{Union{BitMatrix, Matrix{Bool}}}","page":"Functions","title":"Skylight.detect_edges","text":"detect_edges(arr::Array{Bool, 2})\n\nDetects edges in a two-dimensional Boolean array by comparing each element with its neighbors in all four cardinal directions (up, down, left, and right). An edge is considered to be present at a location if the Boolean value at that location is different from the value of any of its neighbors.\n\nArguments\n\narr::Array{Bool, 2}: a two-dimensional Boolean array.\n\nReturns\n\nArray{Bool, 2}: a two-dimensional Boolean array of the same size as the input, where true indicates the presence of an edge and false indicates its absence.\n\nNotes\n\nThis function assumes that the input array is padded with false (or 0) at the boundaries. You might want to add boundary condition checking or padding if your input does not meet this condition.\nThis function uses \"edge wrapping\" when it shifts the array, meaning the values at the edge of the array \"wrap around\" to the opposite edge. If you want a different boundary condition (such as padding with false), you would need to adjust the creation of the shifted arrays accordingly.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.emissivity_profile-Tuple{AbstractMatrix, AbstractSpacetime, AbstractAccretionDisk, LamppostCorona}","page":"Functions","title":"Skylight.emissivity_profile","text":"Assumes unit energy in the rest frame of the emitter\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.energies_quotients-Tuple{AbstractMatrix, AbstractSpacetime, AbstractAccretionDisk}","page":"Functions","title":"Skylight.energies_quotients","text":"Assuming all photons are emitted with unit initial energy\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.equatorial_ring_areas-Tuple{AbstractVector, AbstractSpacetime}","page":"Functions","title":"Skylight.equatorial_ring_areas","text":"equatorial_ring_areas(edges, spacetime)\n\nApproximate areas of the equatorial rings delimited by edges in spacetime. The spacetime must be stationary and axisymmetric. The areas are computed using the formula 2π*sqrt(g[2,2]*g[4,4])*Δr, where g is the metric evaluated at the center of the ring.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.event_horizon_radius-Tuple{Any}","page":"Functions","title":"Skylight.event_horizon_radius","text":"event_horizon_radius(spacetime)\n\nRadius of the event horizon of the given spacetime. Defined only for black hole spacetimes.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.horizons-Tuple{FRKerrSpacetime}","page":"Functions","title":"Skylight.horizons","text":"May return negative roots\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.infer_num_bins-NTuple{7, Any}","page":"Functions","title":"Skylight.infer_num_bins","text":"infer_num_bins(q, at_source, start, stop, bin_size_conditioner, edge_width, camera)\n\nInfer the number of bins from the energy quotients and the bin size conditioner. It chooses the larges number of bins that satisfies that the bin size is larger than the conditioner times the maximum local variation of the energy quotients, for a given approximation of the local variation.\n\nArguments\n\nq: Array of energy quotients.\nat_source: Array of booleans indicating whether the final position is at the source.\nstart: Lower bound of the range to be binned.\nstop: Upper bound of the range to be binned.\nbin_size_conditioner: Conditioner of the bin size.\nedge_width: Width of the edge to be ignored for bin size conditioning (since edges have unusually large local variations, especially in the presence of light-rings and similar phenomena).\ncamera: Image plane.\n\nReturns\n\nnum_bins: Number of bins.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.initialize-Tuple{PinholeCamera, Skylight.AbstractOTEConfigurations}","page":"Functions","title":"Skylight.initialize","text":"Sets the bundle of rays at the camera position. The rays are initialized on a tetrad which has a static four-velocity and  a spherical-like spatial triad. The rays have unit energy in this tetrad.  See docs/pinholecamera.md for more details\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.instantiate_custom_type-Tuple{Dict{Symbol}}","page":"Functions","title":"Skylight.instantiate_custom_type","text":"instantiate_custom_type(dict)\n\nCreate an instance of a custom type using a dictionary. This version supports custom types created using the @with_kw macro from the Parameters.jl package and handles nested dictionaries. The dictionary and its nested subdictionaries must contain a _typename key whose value is the name of the custom type. \n\nArguments\n\ndict::Dict{Symbol, }: A dictionary containing the custom type's name (stored in the _typename key) and field values.\n\nReturns\n\nAn instance of the custom type with the field values specified in the input dictionary, including instances created from nested dictionaries.\n\nExample\n\n```julia using Parameters\n\n@with_kw struct MyNestedType     a::Int end\n\n@with_kw struct MyTypeWithKW     b::Float64     nested::MyNestedType end\n\nmydict = Dict(:typename => \"MyTypeWithKW\",                :b => 2.0,                :nested => Dict(:_typename => \"MyNestedType\",                                :a => 1))\n\nmyinstance = instantiatecustomtype(mydict)\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.inv4x4sym!-Tuple{Matrix{Float64}, Matrix{Float64}}","page":"Functions","title":"Skylight.inv4x4sym!","text":"Computes the inverse of a 4x4 symmetric matrix using the closed-form solution for the inverse.\n\nArguments:\n\ninv_matrix: mutable array of size (4,4) to store the resulting inverse matrix.\nmatrix: array of size (4,4) containing the input symmetric matrix.\n\nReturns: nothing.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.is_final_position_at_edge-Tuple{Any, Any}","page":"Functions","title":"Skylight.is_final_position_at_edge","text":"is_final_position_at_edge(output_data, configurations)\n\nDetermine whether the final position of each ray is at the edge of the source for a given set of configurations.\n\nArguments\n\noutput_data: a multi-dimensional array containing output data for each ray.\nconfigurations: a data structure containing the spacetime and radiative model configurations.\n\nReturns\n\nA boolean grid indicating whether each ray's final position is at the edge of the source.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.is_final_position_at_edge-Tuple{Int64, Any, Any}","page":"Functions","title":"Skylight.is_final_position_at_edge","text":"is_final_position_at_edge(width::Int, output_data, configurations)\n\nDetermine whether the final position of each ray is at the edge of the source for a given set of configurations, considering a specified edge width.\n\nArguments\n\nwidth: the width (in number of cells) to consider as the edge of the source.\noutput_data: a multi-dimensional array containing output data for each ray.\nconfigurations: a data structure containing the spacetime and radiative model configurations.\n\nReturns\n\nA boolean grid indicating whether each ray's final position is within the specified width of the edge of the source.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.is_final_position_at_observer-Tuple{Any, Any}","page":"Functions","title":"Skylight.is_final_position_at_observer","text":"is_final_position_at_observer(output_data, configurations)\n\nDetermine whether the final position of each ray is at the observer for a given set of configurations.\n\nArguments\n\noutput_data: a multi-dimensional array containing output data for each ray.\nconfigurations: a data structure containing the spacetime and radiative model configurations.\n\nReturns\n\nA boolean grid indicating whether each ray's final position is at the observer.\n\nNotes\n\nThe function is_final_position_at_observer should already be defined elsewhere, and is used within this function to check the final position of each ray.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.is_final_position_at_source-Tuple{AbstractMatrix, Any}","page":"Functions","title":"Skylight.is_final_position_at_source","text":"is_final_position_at_source(output_data, configurations)\n\nDetermine whether the final position of each ray is at the source for a given set of configurations.\n\nArguments\n\noutput_data: a multi-dimensional array containing output data for each ray.\nconfigurations: a data structure containing the spacetime and radiative model configurations.\n\nReturns\n\nA boolean grid indicating whether each ray's final position is at the source.\n\nNotes\n\nThe function is_final_position_at_source should already be defined elsewhere, and is used within this function to check the final position of each ray.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.is_hdf5_supported_type-Tuple{Any}","page":"Functions","title":"Skylight.is_hdf5_supported_type","text":"is_hdf5_supported_type(value)\n\nCheck if a given value is of a type that can be directly saved using the HDF5.jl package. This function can be used to determine whether a custom type or one of its fields can be saved to an HDF5 file without further conversion.\n\nAccording to the HDF5.jl documentation, the supported types include:\n\nSigned and unsigned integers (8, 16, 32, and 64 bits)\nFloat32 and Float64\nComplex versions of numeric types\nArrays of supported numeric types (including complex versions)\nAbstractString (ASCIIString and UTF8String)\nArrays of supported string types (ASCIIString and UTF8String)\n\nArguments\n\nvalue: The value to be checked for HDF5 support.\n\nReturns\n\nA Bool indicating whether the input value is of a type supported by HDF5.jl.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.isco_radius-Tuple{Any, Any}","page":"Functions","title":"Skylight.isco_radius","text":"isco_radius(spacetime, rotation_sense::AbstractRotationSense)\n\nRadius of the innermost stable circular orbit in the given spacetime and rotation sense (prograde or  retrograde), if defined.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.isco_radius-Tuple{FRKerrSpacetime, AbstractRotationSense}","page":"Functions","title":"Skylight.isco_radius","text":"Set for M=1\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.line_emission_spectrum-Tuple{Any, Any, VacuumOTEConfigurations}","page":"Functions","title":"Skylight.line_emission_spectrum","text":"line_emission_spectrum(initial_data, output_data, configurations::VacuumOTEConfigurations; \n                       bin_size::Number=NaN, num_bins::Int=NaN,\n                       start::Number=NaN, stop::Number=NaN)\n\nCompute the binned intensity of a line emission spectrum.\n\nArguments\n\ninitial_data: Initial condition data.\noutput_data: Output data from the radiation model.\nconfigurations::VacuumOTEConfigurations: Configuration parameters for the model.\n\nKeywords\n\nbin_size::Union{Nothing, Number}=nothing: Size of each bin. Either bin_size or num_bins must be specified.\nnum_bins::Union{Nothing, Number}=nothing: Number of bins. Either bin_size or num_bins must be specified.\nstart::Union{Nothing, Number}=nothing: Lower bound of the range to be binned. If unspecified, the minimum of the energy quotients will be used.\nstop::Union{Nothing, Number}=nothing: Upper bound of the range to be binned. If unspecified, the maximum of the energy quotients will be used.\nobserver_four_velocity::AbstractVector (optional): The four-velocity of the observer. If not provided, a default static four-velocity will be used.\nflux_direction::AbstractVector (optional): The direction in which to measure the flu. If not provided, a default direction will be used.\n\nReturns\n\nbinned_fluxes: Array of the binned intensity in each bin.\nbins: Array of the bin edges.\n\nNotes\n\nobserver_four_velocity and flux_direction are only accepted if configurations.camera is a PinholeCamera.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_callback_params_from_hdf5-Tuple{String, Int64}","page":"Functions","title":"Skylight.load_callback_params_from_hdf5","text":"load_callback_params_from_hdf5(filename::String, run_index::Int)\n\nLoad the callback parameters of a specific run from an HDF5 file and instantiate the custom type if possible.\n\nArguments\n\nfilename: The path to the HDF5 file.\nrun_index: The index of the run to load the callback parameters from.\n\nReturns\n\nAn instance of the custom type representing the callback parameters, or a dictionary if the custom type cannot be instantiated.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_configurations_from_hdf5-Tuple{String}","page":"Functions","title":"Skylight.load_configurations_from_hdf5","text":"load_configurations_from_hdf5(filename::String)\n\nLoad configurations data from an HDF5 file.\n\nArguments\n\nfilename::String: The path to the HDF5 file.\n\nReturns\n\nAn instance of the configuration type containing the configurations data stored in the HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_initial_data_from_hdf5-Tuple{String}","page":"Functions","title":"Skylight.load_initial_data_from_hdf5","text":"load_initial_data_from_hdf5(filename::String)\n\nLoad initial data from an HDF5 file.\n\nArguments\n\nfilename::String: The path to the HDF5 file.\n\nReturns\n\nThe initial data stored in the HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_nested_dict_from_hdf5-Tuple{HDF5.Group}","page":"Functions","title":"Skylight.load_nested_dict_from_hdf5","text":"load_nested_dict_from_hdf5(group::HDF5Group)\n\nConvert an HDF5 group to a dictionary. If the value is \"nothing\", the value in the dict will be nothing.\n\nArguments\n\ngroup::HDF5Group: The HDF5 group to convert to a dictionary.\n\nReturns\n\nA dictionary containing the data stored in the HDF5 group.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_output_data_from_hdf5-Tuple{String, Int64}","page":"Functions","title":"Skylight.load_output_data_from_hdf5","text":"load_output_data_from_hdf5(filename::String, run_index::Int)\n\nLoad the output data of a specific run from an HDF5 file.\n\nArguments\n\nfilename: The path to the HDF5 file.\nrun_index: The index of the run to load the output data from.\n\nReturns\n\nThe output data of the specified run.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_output_data_from_hdf5-Tuple{String, Vector{Int64}}","page":"Functions","title":"Skylight.load_output_data_from_hdf5","text":"load_output_data_from_hdf5(filename::String, run_indices::Vector{Int})\n\nLoad output data for a selected set of runs from an HDF5 file.\n\nArguments\n\nfilename::String: The path to the HDF5 file.\nrun_indices::Vector{Int}: A vector of integers indicating which runs' output data to load.\n\nReturns\n\nAn array containing the output data for the selected runs.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.load_runs_from_hdf5-Tuple{String, Vector{Int64}}","page":"Functions","title":"Skylight.load_runs_from_hdf5","text":"load_runs(filename::String, run_indices::Vector{Int})\n\nLoad a set of runs specified by their indices from an HDF5 file.\n\nArguments\n\nfilename: The path to the HDF5 file.\nrun_indices: A vector containing the indices of the runs to be loaded.\n\nReturns\n\nA vector of tuples, each containing the outputdata, callback dictionary, callbackparameters, and kwargs dictionary for the specified runs.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.lorentz_factors-Tuple{AbstractMatrix, AbstractSpacetime, AbstractRadiativeModel}","page":"Functions","title":"Skylight.lorentz_factors","text":"lorentz_factors(positions, spacetime, model)\n\nLorentz factors of the rest frame four velocities of `model` at given `positions`.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.mbco_radius-Tuple{Any, Any}","page":"Functions","title":"Skylight.mbco_radius","text":"mbco_radius(spacetime, rotation_sense::AbstractRotationSense)\n\nRadius of the marginally bound circular orbit in the given spacetime and rotation sense (prograde or retrograde), if defined.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.mbco_radius-Tuple{FRKerrSpacetime, AbstractRotationSense}","page":"Functions","title":"Skylight.mbco_radius","text":"Set for M=1\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric!-NTuple{4, Any}","page":"Functions","title":"Skylight.metric!","text":"metric!(g, position, spacetime, cache)\n\nEvaluate the spacetime metric at the given position and store the result in the given array using cache for temporary storage.  \n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric!-Tuple{Any, Any, RARSpacetime}","page":"Functions","title":"Skylight.metric!","text":"\"Ruffini-Arguelles-Rueda metric for dark-matter halo\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric-Tuple{Any, AbstractSpacetime, Any}","page":"Functions","title":"Skylight.metric","text":"metric(position, spacetime, cache)\n\nEvaluate the spacetime metric at the given position and return the result using a cache object as temporary storage. \n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric-Tuple{Any, AbstractSpacetime}","page":"Functions","title":"Skylight.metric","text":"metric(position, spacetime)\n\nEvaluate the spacetime metric at the given position and return the result. \n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric_inverse!-Tuple{Any, Any, AbstractSpacetime, Any, Any}","page":"Functions","title":"Skylight.metric_inverse!","text":"metric_inverse!(ginv, position, spacetime, g, cache)\n\nEvaluate the inverse of the metric at the given position  and store the result in the given array, using g and cache for temporary storage. Unless a more specialized method is defined, a fast inversion method for 4x4 symmetric matrices is used.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric_jacobian!-Tuple{Any, Any, AbstractSpacetime, Any, Any}","page":"Functions","title":"Skylight.metric_jacobian!","text":"metric_jacobian!(∂g, position, spacetime::AbstractSpacetime, g)\n\nComputes the Jacobian matrix of the metric function with respect to spacetime coordinates using forward-mode automatic differentiation.\n\nArguments:\n\n∂g: mutable array of size (4,4,4) to store the resulting Jacobian matrix.\nposition: tuple of four numbers representing a position in spacetime.\nspacetime: object representing the spacetime.\ng: array of size (4,4) containing the metric evaluated at the given position.\n\nReturns: nothing.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.metric_jacobian!-Tuple{Any, Any, Function, Any, ForwardDiff.JacobianConfig}","page":"Functions","title":"Skylight.metric_jacobian!","text":"metric_jacobian!(∂g, position, spacetime_metric_field::Function, g, cfg::ForwardDiff.JacobianConfig)\n\nComputes the Jacobian matrix of the metric function with respect to spacetime coordinates using forward-mode automatic differentiation.\n\nArguments:\n\n∂g: mutable array of size (4,4,4) to store the resulting Jacobian matrix.\nposition: tuple of four numbers representing a position in spacetime.\nspacetime: object representing the spacetime.\ng: array of size (4,4) containing the metric evaluated at the given position.\ncfg: object of type ForwardDiff.JacobianConfig with preallocated work buffers \n\nReturns: nothing.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.midpoints-Tuple{AbstractVector}","page":"Functions","title":"Skylight.midpoints","text":"midpoints(edges)\n\nReturns midpoints of given edges\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.observed_bolometric_intensities-Tuple{AbstractMatrix, AbstractMatrix, VacuumOTEConfigurations, PinholeCamera}","page":"Functions","title":"Skylight.observed_bolometric_intensities","text":"observedbolometricintensities(initialdata, outputdata, configurations::VacuumOTEConfigurations, camera::PinholeCamera; observerfourvelocity=nothing) \n\nCompute observed bolometric intensities and energy quotients for a set of rays defined by the initial and final conditions. The function also checks whether the final position of each ray is at the source, in which case it proceeds with computation, else it skips to the next ray and the values are set to zero. \n\n# Arguments\n\ninitial_data::AbstractMatrix: A matrix containing the initial data of the rays. The first four entries for each ray represent the initial position, while entries five to eight represent the initial momentum.\noutput_data::AbstractMatrix: A matrix containing the final data of the rays. The first four entries for each ray represent the final position, while entries five to eight represent the final momentum.\nconfigurations::VacuumOTEConfigurations: The configurations with which the initial and output data were obtained.\ncamera::PinholeCamera: The camera model used to capture the scene.\nobserver_four_velocity::AbstractVector (optional): The four-velocity of the observer. If not provided, a default static four-velocity will be used.\n\nReturns\n\nIobs::Vector: A vector of observed bolometric intensities for each ray, normalized by the distance to the image plane. The intensities are in CGS units.\nq::Vector: A vector of energy quotients for each ray, representing the ratio of final energy in the local emission frame to initial energy in the observer frame.\n\nNotes\n\nOutput units are CGS. The observer four-velocity and flux direction, if provided, must satisfy the conditions of being timelike and spacelike, respectively, as per the observer metric.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.observed_specific_intensities-Tuple{AbstractMatrix, AbstractMatrix, VacuumOTEConfigurations, ImagePlane, AbstractVector}","page":"Functions","title":"Skylight.observed_specific_intensities","text":"observed_specific_intensities(initial_data, output_data, configurations::VacuumOTEConfigurations)\n\nCompute observed specific intensities and energy quotients for a set of rays defined by the initial and final conditions. The function also checks whether the final position of each ray is at the source, in which case it proceeds with computation, else it skips to the next ray and the values are set to zero.\n\nArguments\n\ninitial_data::AbstractMatrix: A matrix containing the initial data of the rays. The first four entries for each ray represent the initial position, while entries five to eight represent the initial momentum.\noutput_data::AbstractMatrix: A matrix containing the final data of the rays. The first four entries for each ray represent the final position, while entries five to eight represent the final momentum.\nconfigurations::VacuumOTEConfigurations: The configurations with which the initial and output data were obtained.\nobservation_energies::Vector: A vector of energies in CGS units at which the specific intensities are to be computed.\n\nReturns\n\nIobs::Vector: A vector of observed specific intensities in CGS units for each ray, normalized by the distance to the image plane. The intensities are in CGS units.\nq::Vector: A vector of energy quotients for each ray, representing the ratio of final energy in the local emisison frame to initial energy in the observer frame.\n\nNotes\n\nInput energy units must be CGS. Output units are CGS.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.observed_specific_intensities-Tuple{AbstractMatrix, AbstractMatrix, VacuumOTEConfigurations, PinholeCamera, Any}","page":"Functions","title":"Skylight.observed_specific_intensities","text":"observed_specific_intensities(initial_data, output_data, configurations::VacuumOTEConfigurations, observation_energies; observer_four_velocity=nothing)\n\nCompute observed specific intensities and energy quotients for a set of rays defined by the initial and final conditions. The function also checks whether the final position of each ray is at the source, in which case it proceeds with computation, else it skips to the next ray and the values are set to zero.\n\nArguments\n\ninitial_data::AbstractMatrix: A matrix containing the initial data of the rays. The first four entries for each ray represent the initial position, while entries five to eight represent the initial momentum.\noutput_data::AbstractMatrix: A matrix containing the final data of the rays. The first four entries for each ray represent the final position, while entries five to eight represent the final momentum.\nconfigurations::VacuumOTEConfigurations: The configurations with which the initial and output data were obtained.\nobservation_energies::Vector: A vector of energies in CGS units at which the specific intensities are to be computed.\nobserver_four_velocity::AbstractVector (optional): The four-velocity of the observer. If not provided, a default static four-velocity will be used.\n\nReturns\n\nIobs::Matrix: A matrix of observed specific intensities in CGS units for each ray, normalized by the distance to the image plane. The intensities are in CGS units.\nq::Vector: A vector of energy quotients for each ray, representing the ratio of final energy in the local emission frame to initial energy in the observer frame.\n\nNotes\n\nInput energy units must be CGS. Output units are CGS. The observer four-velocity and flux direction, if provided, must satisfy the conditions of being timelike and spacelike, respectively, as per the observer metric.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.orthogonal_projection-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.orthogonal_projection","text":"Projection of v orthogonal to normalized timelike vector u\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.orthonormalize!-NTuple{4, Any}","page":"Functions","title":"Skylight.orthonormalize!","text":"orthonormalize!(dyad::Matrix, time_vector::Vector, space_vector::Vector, metric)\n\nOrthonormalize the dyad `dyad` with respect to the metric `metric` and the vectors `time_vector` and `space_vector`.\nBoth `time_vector` and `space_vector` are assumed to be normalized and orthogonal to each other.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.orthonormalize!-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.orthonormalize!","text":"orthonormalize!(triad::Matrix, time_vector::Vector, metric)\n\nOrthonormalize the triad `triad` with respect to the metric `metric` and the vector `time_vector`.\n`time_vector` is assumed to be normalized.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.outermost_circular_orbit_radius-Tuple{FRKerrSpacetime, AbstractRotationSense}","page":"Functions","title":"Skylight.outermost_circular_orbit_radius","text":"Just return 100M, this if for ion torus\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.packets_tetrad_components!-Tuple{Any, Any}","page":"Functions","title":"Skylight.packets_tetrad_components!","text":"By having Minkowski-null components in the tetrad we guarantee that the momentum is null\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.packets_unit_random_triad_components!-Tuple{Any, Skylight.IsOpaqueInteriorSurface}","page":"Functions","title":"Skylight.packets_unit_random_triad_components!","text":"Sets only positive components along the surface normal\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.planck_function-Tuple{Any, Any}","page":"Functions","title":"Skylight.planck_function","text":"planck_function(E, T)\n\nPlanck's law of black body radiation in terms of energy.\n\nArguments\n\nE::Float64: The energy in erg.\nT::Float64: The temperature in Kelvin.\n\nReturns\n\n::Float64: The planck function in CGS.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.planck_integral-Tuple{Any, Any}","page":"Functions","title":"Skylight.planck_integral","text":"planck_integral(E, T)\n\nEstimation of the Planck integral from E to infinity for temperature T.  Based on \"Planck functions and integrals; methods of computation\" (T.E. Michels) https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19680008986.pdf\n\nArguments\n\nE::Float64: The energy in erg.\nT::Float64: The temperature in Kelvin.\n\nReturns\n\n::Float64: The planck integral in CGS.\n\nRemarks\n\nAn evaluation of the error is too expensive for millions of calls, so we fix N=5. This was checked against scipy integration, yielding at least 3 siginficant digits for all x. When x>1 the amount of siginificant digits is 8 or more\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.points_on_equatorial_plane!-Tuple{Any, Any, Any, CartesianTopology}","page":"Functions","title":"Skylight.points_on_equatorial_plane!","text":"points_on_equatorial_plane!(points, r, φ, ::CartesianTopology)\n\nSets the points on the equatorial plane from spherical coordinates\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.points_on_unit_sphere!-Tuple{Any, Any, Any, CartesianTopology}","page":"Functions","title":"Skylight.points_on_unit_sphere!","text":"points_on_unit_sphere!(points, θ, φ, ::AbstractCoordinatesTopology)\n\nTransforms the points on the unit sphere from the angular coordinates\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.radius-Tuple{Any, Any}","page":"Functions","title":"Skylight.radius","text":"radius(position, spacetime)\n\nRadius of the given position in the given spacetime. \n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.radius-Tuple{Any, SchwarzschildSpacetimeKerrSchildCoordinates}","page":"Functions","title":"Skylight.radius","text":"radius(position, spacetime::SchwarzschildSpacetimeKerrSchildCoordinates)\n\n``r = \\sqrt{x^2 + y^2 + z^2}``\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_azimuthal_angle-Tuple{Any}","page":"Functions","title":"Skylight.random_azimuthal_angle","text":"random_azimuthal_angle(N)\n\nGenerates N random numbers representing azimuthal angles, following a  uniform distribution from 0 to 2π.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_cylindrical_radius-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.random_cylindrical_radius","text":"random_cylindrical_radius(N, rmin, rmax)\n\nGenerates N random numbers representing cylindrical radii, following a  uniform distribution between rmin and rmax.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_polar_angle-Tuple{Any, Any}","page":"Functions","title":"Skylight.random_polar_angle","text":"random_polar_angle(N, θmax)\n\nGenerates N random numbers representing polar angles, following a  uniform distribution from 0 to θmax (in radians).\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_uniform_points_annulus!-NTuple{4, Any}","page":"Functions","title":"Skylight.random_uniform_points_annulus!","text":"random_uniform_points_annulus!(points, rmin, rmax, coords_top)\n\nPopulate the given array points with points randomly and uniformly  distributed in an annulus with inner radius rmin and outer radius rmax. The type of the coordinate system is determined by coords_top.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_uniform_points_disk!-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.random_uniform_points_disk!","text":"random_uniform_points_disk!(points, rmax, coords_top)\n\nPopulate the given array points with points randomly and uniformly  distributed in a disk with radius rmax. The type of the coordinate system is determined by coords_top.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_uniform_points_unit_hemisphere!-Tuple{Any, Any}","page":"Functions","title":"Skylight.random_uniform_points_unit_hemisphere!","text":"random_uniform_points_unit_hemisphere!(points, coords_top)\n\nPopulate the given array points with points randomly and uniformly  distributed on the unit hemisphere. The type of the coordinate system is determined by coords_top.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_uniform_points_unit_hemisphere_xaxis!-Tuple{Any, CartesianTopology}","page":"Functions","title":"Skylight.random_uniform_points_unit_hemisphere_xaxis!","text":"random_uniform_points_unit_hemisphere_xaxis!(v,::CartesianTopology)\n\nPopulate the given array v with points randomly and uniformly  distributed on the unit hemisphere along the x-axis.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_uniform_points_unit_sphere!-Tuple{Any, Any}","page":"Functions","title":"Skylight.random_uniform_points_unit_sphere!","text":"random_uniform_points_unit_sphere!(points, coords_top)\n\nPopulate the given array points with points randomly and uniformly  distributed on the unit sphere. The type of the coordinate system is determined by coords_top.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.random_uniform_points_unit_spherical_cap!-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.random_uniform_points_unit_spherical_cap!","text":"random_uniform_points_unit_spherical_cap!(points, θmax_in_degrees, coords_top)\n\nPopulate the given array points with points randomly and uniformly  distributed in a spherical cap with maximum polar angle θmax_in_degrees degrees. The type of the coordinate system is determined by coords_top.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.rayleigh_jeans_function-Tuple{Any, Any}","page":"Functions","title":"Skylight.rayleigh_jeans_function","text":"rayleigh_jeans_function(E, T)\n\nRayleigh-Jeans law of black body radiation in terms of energy.\n\nArguments\n\nE::Float64: The energy in erg.\nT::Float64: The temperature in Kelvin.\n\nReturns\n\n::Float64: The Rayleigh-Jeans function in CGS.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.rays_tetrad_components!-Tuple{Any, PinholeCamera}","page":"Functions","title":"Skylight.rays_tetrad_components!","text":"By having Minkowski-null components in the tetrad we guarantee that the momentum is null\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.save_nested_dict_to_hdf5-Tuple{Any, Any}","page":"Functions","title":"Skylight.save_nested_dict_to_hdf5","text":"save_nested_dict_to_hdf5(group::HDF5File, nested_dict::Dict{Symbol,})\n\nRecursively save a nested dictionary to an HDF5 group. The function iterates through the key-value pairs in the input dictionary. If a value is a dictionary, it creates a new subgroup and recursively saves the nested dictionary. If a value is not a dictionary, it is saved directly to the current group.\n\nArguments\n\ngroup: An HDF5 group to which the nested dictionary should be saved.\nnested_dict: A nested dictionary with keys of type Symbol and values of any type.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.save_obj_to_hdf5-Tuple{Any, Any, Any}","page":"Functions","title":"Skylight.save_obj_to_hdf5","text":"save_obj_to_hdf5(group::HDF5File, name::String, obj::Any)\n\nSave an object to an HDF5 group by converting it to an HDF5 compatible dictionary and then saving the dictionary to the group. The function creates a new subgroup with the given name and saves the converted dictionary using the save_nested_dict_to_hdf5 function.\n\nArguments\n\ngroup: An HDF5 group to which the object should be saved.\nname: A string representing the name of the subgroup to create for the object.\nobj: An object of any type that should be saved to the HDF5 group.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.save_to_hdf5-Union{Tuple{T}, Tuple{String, AbstractConfigurations, Array, Array{T}}} where T<:Skylight.Run","page":"Functions","title":"Skylight.save_to_hdf5","text":"save_to_hdf5(filename, configurations, initial_data, runs)\n\nSave the provided data to an HDF5 file. The data includes configurations, initialdata, and a collection of runs. Each run contains outputdata, callback, callback_parameters, and kwargs for the solver function.\n\nIf the file exists, it uses the \"r+\" mode to open the file for reading and writing. If the file does not exist, it uses the \"w\" mode to create a new file.\n\nThe file will be organized as follows:\n\n/configurations: A group containing the configurations data.\n/initial_data: A dataset containing the initial data.\n/runs: A group containing subgroups for each run. Each subgroup will have:\n/output_data: A dataset containing the output data.\n/callback: A subgroup containing the callback custom type data.\n/callback_parameters: A subgroup containing the callback parameters data.\n/kwargs: A subgroup containing the kwargs data.\n\nArguments\n\nfilename: The name of the HDF5 file to save the data to. If the file already exists, new data will be appended without overwriting existing content.\nconfigurations: A custom type containing the configurations data. It will be converted to a dictionary using the to_hdf5_compatible_dict function.\ninitial_data: The initial data for the equations.\nruns: An array of tuples containing outputdata, callback custom type, callbackparameters, and kwargs for each run. The callback custom type and callbackparameters should be custom types, which will be converted to dictionaries using the `tohdf5compatibledict` function.\n\nReturns\n\nNothing.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.set_null!-Tuple{Any, Any}","page":"Functions","title":"Skylight.set_null!","text":"returns with unit energy\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.set_null_ingoing_past_directed!-Tuple{Any, Any}","page":"Functions","title":"Skylight.set_null_ingoing_past_directed!","text":"the input time component must be zero for this to work \n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.spherical_symmetry-Tuple{AbstractSpacetime}","page":"Functions","title":"Skylight.spherical_symmetry","text":"spherical_symmetry(spacetime)\n\nReturn IsSphericallySymmetric() if the spacetime is spherically symmetric, IsNotSphericallySymmetric() otherwise.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.stationarity-Tuple{AbstractSpacetime}","page":"Functions","title":"Skylight.stationarity","text":"stationarity(spacetime)\n\nReturn IsStationary() if the spacetime is stationary, IsNotStationary() otherwise.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.tmap-Tuple{Any, Any, Vararg{Any}}","page":"Functions","title":"Skylight.tmap","text":"tmap(f, itr; tasks_per_thread::Int = 2, kwargs...)\n\nApply a given function f to partitions of the iterable itr in parallel.\n\nArguments\n\nf: A function to be applied to each partition of the iterable.\nitr: The iterable to be partitioned and processed.\ntasks_per_thread::Int: An optional parameter to control the number of tasks per thread. Default value is 2.\nkwargs...: Additional keyword arguments that will be passed to the function f.\n\nDescription\n\nThis function divides the iterable itr into chunks, with each chunk size determined by the given tasks_per_thread and the number of available threads. The specified function f is then applied to each chunk in parallel using the @spawn macro. The @sync macro ensures that all tasks are completed before moving on.\n\nExample\n\n```julia function printelements(chunk)     for i in chunk         println(i)     end end tmap(printelements, 1:10; tasksperthread = 2)\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.to_hdf5_compatible_dict-Tuple{T} where T","page":"Functions","title":"Skylight.to_hdf5_compatible_dict","text":"to_hdf5_compatible_dict(obj::T; depth::Int=0, max_depth::Int=5) where T\n\nRecursively convert a custom type obj to a dictionary. This function is useful for preparing custom types for saving to an HDF5 file when the types are not directly supported by the HDF5.jl package.\n\nThe function will attempt to convert each field of the custom type to a dictionary if the field is not an HDF5-supported type. The conversion process is limited by a maximum recursion depth, specified by the max_depth parameter, which defaults to 5.\n\nIf a field is nothing, the value will be saved as the string \"nothing\".\n\nIf a field is a function, the function will be converted to a string using the string function.\n\nIf a field is not an HDF5-supported type and has no fields that can be converted, the function will return nothing when the maximum recursion depth is reached.\n\nArguments\n\nobj::T: The custom type instance to be converted to a dictionary.\ndepth::Int=0 (optional): The current recursion depth, starting at 0. This parameter is used internally and should not typically be set by the user.\nmax_depth::Int=5 (optional): The maximum recursion depth allowed for converting nested custom types.\n\nReturns\n\nA Dict{String, Any} containing the fields of the input custom type, with nested custom types recursively converted to dictionaries. The dictionary will also include a \"_typename\" key with the name of the custom type as a string.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.to_hdf5_compatible_dict-Tuple{T} where T<:SciMLBase.DECallback","page":"Functions","title":"Skylight.to_hdf5_compatible_dict","text":"to_hdf5_compatible_dict(cb::T; depth::Int=0, max_depth::Int=8) where {T<:SciMLBase.DECallback}\n\nConverts a DifferentialEquations.jl callback into a dictionary that can be saved to an HDF5 file for later instantiation.\n\nArguments\n\ncb: The callback to be converted into a dictionary.\ndepth: The current depth of recursion. This is used to prevent infinite recursion.  (default: 0)\nmax_depth: The maximum allowed depth of recursion. If the depth exceeds this value,  the function returns nothing. (default: 8)\n\nReturns\n\nA dictionary where the keys are the names of the fields of the object and the values are  the corresponding field values. Field values are recursively converted to dictionaries  if they are of custom types not supported by HDF5.jl.\n\nNotes\n\nThe dictionary includes an additional entry with the key \"_typename\" and the name of the type  of the object as the value. This is used to reconstruct the original object when loading  the data from the HDF5 file.\nThe function specifically handles certain fields of the DECallback type.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.volume_element-Tuple{Any, AbstractSpacetime, Any, Any}","page":"Functions","title":"Skylight.volume_element","text":"volume_element(position, spacetime, g, cache)\n\nCompute the volume element (square root of minus the determinant of the metric) at the given position  with a fast determinant for 4x4 symmetric matrices, using g and cache for temporary storage.\n\n\n\n\n\n","category":"method"},{"location":"spacetimes/functions/#Skylight.volume_element-Tuple{Any, AbstractSpacetime}","page":"Functions","title":"Skylight.volume_element","text":"volume_element(position, spacetime)\n\nCompute the volume element (square root of minus the determinant of the metric) at the given position  with a fast determinant for 4x4 symmetric matrices.\n\n\n\n\n\n","category":"method"},{"location":"miscellanea/utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"usage/#How-to-use","page":"How to use","title":"How to use","text":"","category":"section"},{"location":"usage/#Units","page":"How to use","title":"Units","text":"","category":"section"},{"location":"usage/","page":"How to use","title":"How to use","text":"Skylight uses geometrized units c = G = 1.","category":"page"},{"location":"usage/#Spacetimes","page":"How to use","title":"Spacetimes","text":"","category":"section"},{"location":"usage/","page":"How to use","title":"How to use","text":"First, you have to choose a spacetime (and coordinates topology). Currently, the available options are:","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"MinkowskiSpacetimeCartesianCoordinates\nMinkowskiSpacetimeSphericalCoordinates\nSchwarzschildSpacetimeKerrSchildCoordinates\nSchwarzschildSpacetimeSphericalCoordinates\nKerrSpacetimeKerrSchildCoordinates\nKerrSpacetimeBoyerLindquistCoordinates\nFRKerrSpacetime\nJohannsenSpacetime\nRARSpacetime\nBosonStarSpacetime\nChargedWormholeSphericalCoordinates\nChargedWormholeRegularCoordinates","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"Some spacetimes depends on a set of parameters and others have no parameters. For example, to instantiate a Kerr spacetime in Kerr-Schild coordinates with mass M=1 and spin aM=05, run ","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"spacetime = KerrSpacetimeKerrSchildCoordinate(M=1.0,a=0.5)","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"Spacetimes without parameters are instantiated just like","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"spacetime = MinkowskiSpacetimeCartesianCoordinates()","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"For more details about the spacetimes and the parameters they need, see the Spacetimes section of the documentation.","category":"page"},{"location":"usage/#Radiative-models","page":"How to use","title":"Radiative models","text":"","category":"section"},{"location":"usage/","page":"How to use","title":"How to use","text":"The currently available radiative models are:","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"ShakuraSunyaevAccretionDisk (provisory temperature profile)\nNovikovThorneAccretionDisk (provisory temperature profile)\nRARAccretionDisk\nAccretionDiskWithTabulatedTemperature\nSyntheticPolarCap","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"The following will be implemented soon:","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"StarAcrossWormhole\nBogdanovPolarCap\nOnionHotSpots\nBlackHoleCorona","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"Radiative models also depend on a set of parameters. To construct a synthetic polar cap, for example ","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"model = Skylight.SyntheticPolarCap(star_radius=5.0,\n                                          angular_speed = 0.05, \n                                          misalignment_angle_in_degrees=90,\n                                          angular_radius_in_degrees=60, \n                                          temperature=1.0)","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"For the details, see the radiative models documentation. ","category":"page"},{"location":"usage/#Image-plane","page":"How to use","title":"Image plane","text":"","category":"section"},{"location":"usage/","page":"How to use","title":"How to use","text":"For the observet-to-emitter scheme, use the following to construct an image plane","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"camera = ImagePlane(distance = 500.0,\n                                observer_inclination_in_degrees = 45,\n                                horizontal_side = 10.0,\n                                vertical_side = 10.0,\n                                horizontal_number_of_pixels = 600,\n                                vertical_number_of_pixels = 600,\n                                observation_times = [0.0,1.0])","category":"page"},{"location":"usage/#Pinhole-camera","page":"How to use","title":"Pinhole camera","text":"","category":"section"},{"location":"usage/","page":"How to use","title":"How to use","text":"More generally, when asymptotic flatness isn't valid, or simply the observer is not located far away enough, a pinhole camera can be used. It can be constructed, for instance, as","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"camera = PinholeCamera(position = [0.0, 500, π/2-π/20, 0.0],\n                        horizontal_aperture_in_degrees = rad2deg(315/500),\n                        vertical_aperture_in_degrees = rad2deg(315/500),\n                        horizontal_number_of_pixels = 600,\n                        vertical_number_of_pixels = 600)","category":"page"},{"location":"usage/#Configurations","page":"How to use","title":"Configurations","text":"","category":"section"},{"location":"usage/","page":"How to use","title":"How to use","text":"The initial data configurations in the observer-to-emitter scheme are constructed as follows","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"configurations = VacuumOTEConfigurations(spacetime=spacetime,\n                                        radiative_model=model,\n                                        camera = camera,\n                                        unit_mass_in_solar_masses = 1.0)","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"where unit_mass_in_solar_masses is the unit mass in solar masses which determines fully the problem units together with c=G=1.","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"In the emitter-to-observer scheme, use the following","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"julia> configurations = VacuumETOConfigurations(spacetime=spacetime,\n                                                     radiative_model=model,\n                                                     number_of_points = 100\n                                                     number_of_packets_per_point = 100, max_radius = 500.0)","category":"page"},{"location":"usage/#Initial-data","page":"How to use","title":"Initial data","text":"","category":"section"},{"location":"usage/","page":"How to use","title":"How to use","text":"Finally, for creating the initial data, use","category":"page"},{"location":"usage/","page":"How to use","title":"How to use","text":"initial_data = initialize(configurations)","category":"page"},{"location":"usage/#Geodesics","page":"How to use","title":"Geodesics","text":"","category":"section"},{"location":"usage/","page":"How to use","title":"How to use","text":"Or you can specify another callback or method by...","category":"page"},{"location":"initialization/pinholecamera/#Pinhole-camera","page":"Pinhole camera","title":"Pinhole camera","text":"","category":"section"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"The energy momentum tensor of the radiation field in terms of the specific intensity is given by","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^{ab} = \\int k^a k^b \\left( \\frac{I\\nu}{\\nu^3} \\right) dVk  $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where dV_k = nu dnu dOmega. Equivalently,","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^{a b} = \\int{S^2} \\int0^\\infty n^a n^b I_\\nu d\\nu d\\Omega  $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where n^a = k^a  nu. The radiative flux of energy in the direction of barn^a measured by an osberver with four-velocity u^a is T^a b u_a barn_b.","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"For discretizing this integral at position x^mu, we choose an orthonormal tetrad. We take $ e0 = \\partialt \\\ne1 = -\\partialr \\\ne2 = \\partial\\phi \\\ne3 = -\\partial\\theta \\\n$ and orthonormalize it with respect to g_alpha beta(x^mu), where (rtheta phi) are some topolgically spherical coordinates on the spacetime. Note that this assumes there is a timelike coordinate t and three spacelike coordinates from which there is a meaningful way of transforming to spherical-like coordinates. In flat spacetime, the interpretation of this tetrad is simple: e_1 points towards the origin, e_2 is parallel to the equatorial plane and e_3 is parallel to the z-axis. Note that the triad we use is not direct. Note also that the choice of tetrad does not actually matter. The procedure we choose is sufficiently general to allow (almost) arbitrary spacetime position, flux direction, and observer four-velocity, but it is particularly well suited for large distances in asymptotically flat spacetimes where the source can be covered by a small spherical sector centered around e_1. Finally, we take coordinates (alpha beta) on S^2 such that  $ \\alpha = \\varphi \\\n\\beta = \\pi/2 -{\\vartheta} $ where (vartheta varphi) are the usual angular coordinates on S^2. The coordinates range over -π le alpha lt pi and -pi2 le beta le pi2. The tetrad components of a vector in these coordinates can be written as $ k^0 = \\nu \\  k^1 = \\nu \\cos \\alpha \\cos \\beta \\\nk^2 = \\nu \\sin \\alpha \\cos \\beta \\\nk^3 = \\nu \\sin \\beta  $ ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Thus, in particular (alpha beta) = (00) maps to e_1. In these coordinates, dOmega = cos beta dalpha dbeta. We only need to take the (alpha beta) coordinate ranges large enough to cover the image of the emitting source. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Finally, we approximate the integral numerically as","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"\\sum{i j k} I{ijk} n^a{ij} n^b{ij} \\Delta \\Omega_{ij} \\Delta \\nu \\, ,     $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where I_ijk = I_nu_k(n^a_ij), the tetrad components of n^a_ij are  $ [1, \\cos \\alphai \\cos \\betaj, \\sin \\alphai \\cos \\betaj, \\sin \\betaj]\\, , $ (we have to transform them to the coordinate frame before contraction), the solid angle of each section is $ \\Delta \\Omega{ij} = \\int{D{ij}} \\cos \\beta d\\alpha d\\beta = 2 \\cos(\\betaj) \\sin \\left(\\frac{\\Delta \\beta}{2} \\right) \\Delta \\alpha, $ and D{ij} = [\\alphai-\\Delta \\alpha/2, \\alphai+\\Delta \\alpha/2] \\times [\\betaj - \\Delta \\beta / 2, \\betaj + \\Delta \\beta /2]$. We took a uniform grid such that  $ \\alphai = -s\\alpha/2+(i-1/2)\\Delta \\alpha \\  \\betaj = -s\\beta/2+(j-1/2)\\Delta \\beta \\\n\\Delta \\alpha = s\\alpha/N\\alpha \\\n\\Delta \\beta = s\\beta/N\\beta \\\n1 \\le i \\le N\\alpha \\  1 \\le j \\le N\\beta $. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where s_alpha s_beta are the horizontal and vertical aperture angles respectively, and N_alpha, N_beta are the numbers of pixels. The total solid angle is Delta Omega = 2 sin(s_beta2)s_alpha   The energy momentum tensor of the radiation field in terms of the specific intensity is given by","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^{ab} = \\int k^a k^b \\left( \\frac{I\\nu}{\\nu^3} \\right) dVk  $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where dV_k = nu dnu dOmega. Equivalently,","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^{a b} = \\int{S^2} \\int0^\\infty n^a n^b I_\\nu d\\nu d\\Omega  $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where n^a = k^a  nu. The radiative flux of energy in the direction of barn^a measured by an osberver with four-velocity u^a is T^a b u_a barn_b.","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"For discretizing this integral at position x^mu, we choose an orthonormal tetrad. We take $ e0 = \\partialt \\\ne1 = -\\partialr \\\ne2 = \\partial\\phi \\\ne3 = -\\partial\\theta \\\n$ and orthonormalize it with respect to g_alpha beta(x^mu), where (rtheta phi) are some topolgically spherical coordinates on the spacetime. Note that this assumes there is a timelike coordinate t and three spacelike coordinates from which there is a meaningful way of transforming to spherical-like coordinates. In flat spacetime, the interpretation of this tetrad is simple: e_1 points towards the origin, e_2 is parallel to the equatorial plane and e_3 is parallel to the z-axis. Note that the triad we use is not direct. Note also that the choice of tetrad does not actually matter. The procedure we choose is sufficiently general to allow (almost) arbitrary spacetime position, flux direction, and observer four-velocity, but it is particularly well suited for large distances in asymptotically flat spacetimes where the source can be covered by a small spherical sector centered around e_1. Finally, we take coordinates (alpha beta) on S^2 such that  $ \\alpha = \\varphi \\\n\\beta = \\pi/2 -{\\vartheta} $ where (vartheta varphi) are the usual angular coordinates on S^2. The coordinates range over -π le alpha lt pi and -pi2 le beta le pi2. The tetrad components of a vector in these coordinates can be written as $ k^0 = \\nu \\  k^1 = \\nu \\cos \\alpha \\cos \\beta \\\nk^2 = \\nu \\sin \\alpha \\cos \\beta \\\nk^3 = \\nu \\sin \\beta  $ ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Thus, in particular (alpha beta) = (00) maps to e_1. In these coordinates, dOmega = cos beta dalpha dbeta. We only need to take the (alpha beta) coordinate ranges large enough to cover the image of the emitting source. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Finally, we approximate the integral numerically as","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"\\sum{i j k} I{ijk} n^a{ij} n^b{ij} \\Delta \\Omega_{ij} \\Delta \\nu \\, ,     $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where I_ijk = I_nu_k(n^a_ij), the tetrad components of n^a_ij are  $ [1, \\cos \\alphai \\cos \\betaj, \\sin \\alphai \\cos \\betaj, \\sin \\betaj]\\, , $ (we have to transform them to the coordinate frame before contraction), the solid angle of each section is $ \\Delta \\Omega{ij} = \\int{D{ij}} \\cos \\beta d\\alpha d\\beta = 2 \\cos(\\betaj) \\sin \\left(\\frac{\\Delta \\beta}{2} \\right) \\Delta \\alpha, $ and D{ij} = [\\alphai-\\Delta \\alpha/2, \\alphai+\\Delta \\alpha/2] \\times [\\betaj - \\Delta \\beta / 2, \\betaj + \\Delta \\beta /2]$. We took a uniform grid such that  $ \\alphai = -s\\alpha/2+(i-1/2)\\Delta \\alpha \\  \\betaj = -s\\beta/2+(j-1/2)\\Delta \\beta \\\n\\Delta \\alpha = s\\alpha/N\\alpha \\\n\\Delta \\beta = s\\beta/N\\beta \\\n1 \\le i \\le N\\alpha \\  1 \\le j \\le N\\beta $. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where s_alpha s_beta are the horizontal and vertical aperture angles respectively, and N_alpha, N_beta are the numbers of pixels. The total solid angle is Delta Omega = 2 sin(s_beta2)s_alpha   The energy momentum tensor of the radiation field in terms of the specific intensity is given by","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^{ab} = \\int k^a k^b \\left( \\frac{I\\nu}{\\nu^3} \\right) dVk  $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where dV_k = nu dnu dOmega. Equivalently,","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^{a b} = \\int{S^2} \\int0^\\infty n^a n^b I_\\nu d\\nu d\\Omega  $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where n^a = k^a  nu. The radiative flux of energy in the direction of barn^a measured by an osberver with four-velocity u^a is T^a b u_a barn_b.","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"For discretizing this integral at position x^mu, we choose an orthonormal tetrad. We take $ e0 = \\partialt \\\ne1 = -\\partialr \\\ne2 = \\partial\\phi \\\ne3 = -\\partial\\theta \\\n$ and orthonormalize it with respect to g_alpha beta(x^mu), where (rtheta phi) are some topolgically spherical coordinates on the spacetime. Note that this assumes there is a timelike coordinate t and three spacelike coordinates from which there is a meaningful way of transforming to spherical-like coordinates. In flat spacetime, the interpretation of this tetrad is simple: e_1 points towards the origin, e_2 is parallel to the equatorial plane and e_3 is parallel to the z-axis. Note that the triad we use is not direct. Note also that the choice of tetrad does not actually matter. The procedure we choose is sufficiently general to allow (almost) arbitrary spacetime position, flux direction, and observer four-velocity, but it is particularly well suited for large distances in asymptotically flat spacetimes where the source can be covered by a small spherical sector centered around e_1. Finally, we take coordinates (alpha beta) on S^2 such that  $ \\alpha = \\varphi \\\n\\beta = \\pi/2 -{\\vartheta} $ where (vartheta varphi) are the usual angular coordinates on S^2. The coordinates range over -π le alpha lt pi and -pi2 le beta le pi2. The tetrad components of a vector in these coordinates can be written as $ k^0 = \\nu \\  k^1 = \\nu \\cos \\alpha \\cos \\beta \\\nk^2 = \\nu \\sin \\alpha \\cos \\beta \\\nk^3 = \\nu \\sin \\beta  $ ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Thus, in particular (alpha beta) = (00) maps to e_1. In these coordinates, dOmega = cos beta dalpha dbeta. We only need to take the (alpha beta) coordinate ranges large enough to cover the image of the emitting source. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Finally, we approximate the integral numerically as","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"\\sum{i j k} I{ijk} n^a{ij} n^b{ij} \\Delta \\Omega_{ij} \\Delta \\nu \\, ,     $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where I_ijk = I_nu_k(n^a_ij), the tetrad components of n^a_ij are  $ [1, \\cos \\alphai \\cos \\betaj, \\sin \\alphai \\cos \\betaj, \\sin \\betaj]\\, , $ (we have to transform them to the coordinate frame before contraction), the solid angle of each section is $ \\Delta \\Omega{ij} = \\int{D{ij}} \\cos \\beta d\\alpha d\\beta = 2 \\cos(\\betaj) \\sin \\left(\\frac{\\Delta \\beta}{2} \\right) \\Delta \\alpha, $ and D{ij} = [\\alphai-\\Delta \\alpha/2, \\alphai+\\Delta \\alpha/2] \\times [\\betaj - \\Delta \\beta / 2, \\betaj + \\Delta \\beta /2]$. We took a uniform grid such that  $ \\alphai = -s\\alpha/2+(i-1/2)\\Delta \\alpha \\  \\betaj = -s\\beta/2+(j-1/2)\\Delta \\beta \\\n\\Delta \\alpha = s\\alpha/N\\alpha \\\n\\Delta \\beta = s\\beta/N\\beta \\\n1 \\le i \\le N\\alpha \\  1 \\le j \\le N\\beta $. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where s_alpha s_beta are the horizontal and vertical aperture angles respectively, and N_alpha, N_beta are the numbers of pixels. The total solid angle is Delta Omega = 2 sin(s_beta2)s_alpha   The energy momentum tensor of the radiation field in terms of the specific intensity is given by","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^{ab} = \\int k^a k^b \\left( \\frac{I\\nu}{\\nu^3} \\right) dVk  $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where dV_k = nu dnu dOmega. Equivalently,","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^{a b} = \\int{S^2} \\int0^\\infty n^a n^b I_\\nu d\\nu d\\Omega  $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where n^a = k^a  nu. The radiative flux of energy in the direction of barn^a measured by an osberver with four-velocity u^a is T^a b u_a barn_b.","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"For discretizing this integral at position x^mu, we choose an orthonormal tetrad. We take $ e0 = \\partialt \\\ne1 = -\\partialr \\\ne2 = \\partial\\phi \\\ne3 = -\\partial\\theta \\\n$ and orthonormalize it with respect to g_alpha beta(x^mu), where (rtheta phi) are some topolgically spherical coordinates on the spacetime. Note that this assumes there is a timelike coordinate t and three spacelike coordinates from which there is a meaningful way of transforming to spherical-like coordinates. In flat spacetime, the interpretation of this tetrad is simple: e_1 points towards the origin, e_2 is parallel to the equatorial plane and e_3 is parallel to the z-axis. Note that the triad we use is not direct. Note also that the choice of tetrad does not actually matter. The procedure we choose is sufficiently general to allow (almost) arbitrary spacetime position, flux direction, and observer four-velocity, but it is particularly well suited for large distances in asymptotically flat spacetimes where the source can be covered by a small spherical sector centered around e_1. Finally, we take coordinates (alpha beta) on S^2 such that  $ \\alpha = \\varphi \\\n\\beta = \\pi/2 -{\\vartheta} $ where (vartheta varphi) are the usual angular coordinates on S^2. The coordinates range over -π le alpha lt pi and -pi2 le beta le pi2. The tetrad components of a vector in these coordinates can be written as $ k^0 = \\nu \\  k^1 = \\nu \\cos \\alpha \\cos \\beta \\\nk^2 = \\nu \\sin \\alpha \\cos \\beta \\\nk^3 = \\nu \\sin \\beta  $ ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Thus, in particular (alpha beta) = (00) maps to e_1. In these coordinates, dOmega = cos beta dalpha dbeta. We only need to take the (alpha beta) coordinate ranges large enough to cover the image of the emitting source. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Finally, we approximate the integral numerically as","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"\\sum{i j k} I{ijk} n^a{ij} n^b{ij} \\Delta \\Omega_{ij} \\Delta \\nu \\, ,     $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where I_ijk = I_nu_k(n^a_ij), the tetrad components of n^a_ij are  $ [1, \\cos \\alphai \\cos \\betaj, \\sin \\alphai \\cos \\betaj, \\sin \\betaj]\\, , $ (we have to transform them to the coordinate frame before contraction), the solid angle of each section is $ \\Delta \\Omega{ij} = \\int{D{ij}} \\cos \\beta d\\alpha d\\beta = 2 \\cos(\\betaj) \\sin \\left(\\frac{\\Delta \\beta}{2} \\right) \\Delta \\alpha, $ and D{ij} = [\\alphai-\\Delta \\alpha/2, \\alphai+\\Delta \\alpha/2] \\times [\\betaj - \\Delta \\beta / 2, \\betaj + \\Delta \\beta /2]$. We took a uniform grid such that  $ \\alphai = -s\\alpha/2+(i-1/2)\\Delta \\alpha \\  \\betaj = -s\\beta/2+(j-1/2)\\Delta \\beta \\\n\\Delta \\alpha = s\\alpha/N\\alpha \\\n\\Delta \\beta = s\\beta/N\\beta \\\n1 \\le i \\le N\\alpha \\  1 \\le j \\le N\\beta $. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where s_alpha s_beta are the horizontal and vertical aperture angles respectively, and N_alpha, N_beta are the numbers of pixels. The total solid angle is Delta Omega = 2 sin(s_beta2)s_alpha   The energy momentum tensor of the radiation field in terms of the specific intensity is given by","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^{ab} = \\int k^a k^b \\left( \\frac{I\\nu}{\\nu^3} \\right) dVk  $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where dV_k = nu dnu dOmega. Equivalently,","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"T^{a b} = \\int{S^2} \\int0^\\infty n^a n^b I_\\nu d\\nu d\\Omega  $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where n^a = k^a  nu. The radiative flux of energy in the direction of barn^a measured by an osberver with four-velocity u^a is T^a b u_a barn_b.","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"For discretizing this integral at position x^mu, we choose an orthonormal tetrad. We take $ e0 = \\partialt \\\ne1 = -\\partialr \\\ne2 = \\partial\\phi \\\ne3 = -\\partial\\theta \\\n$ and orthonormalize it with respect to g_alpha beta(x^mu), where (rtheta phi) are some topolgically spherical coordinates on the spacetime. Note that this assumes there is a timelike coordinate t and three spacelike coordinates from which there is a meaningful way of transforming to spherical-like coordinates. In flat spacetime, the interpretation of this tetrad is simple: e_1 points towards the origin, e_2 is parallel to the equatorial plane and e_3 is parallel to the z-axis. Note that the triad we use is not direct. Note also that the choice of tetrad does not actually matter. The procedure we choose is sufficiently general to allow (almost) arbitrary spacetime position, flux direction, and observer four-velocity, but it is particularly well suited for large distances in asymptotically flat spacetimes where the source can be covered by a small spherical sector centered around e_1. Finally, we take coordinates (alpha beta) on S^2 such that  $ \\alpha = \\varphi \\\n\\beta = \\pi/2 -{\\vartheta} $ where (vartheta varphi) are the usual angular coordinates on S^2. The coordinates range over -π le alpha lt pi and -pi2 le beta le pi2. The tetrad components of a vector in these coordinates can be written as $ k^0 = \\nu \\  k^1 = \\nu \\cos \\alpha \\cos \\beta \\\nk^2 = \\nu \\sin \\alpha \\cos \\beta \\\nk^3 = \\nu \\sin \\beta  $ ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Thus, in particular (alpha beta) = (00) maps to e_1. In these coordinates, dOmega = cos beta dalpha dbeta. We only need to take the (alpha beta) coordinate ranges large enough to cover the image of the emitting source. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"Finally, we approximate the integral numerically as","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"$","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"\\sum{i j k} I{ijk} n^a{ij} n^b{ij} \\Delta \\Omega_{ij} \\Delta \\nu \\, ,     $","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where I_ijk = I_nu_k(n^a_ij), the tetrad components of n^a_ij are  $ [1, \\cos \\alphai \\cos \\betaj, \\sin \\alphai \\cos \\betaj, \\sin \\betaj]\\, , $ (we have to transform them to the coordinate frame before contraction), the solid angle of each section is $ \\Delta \\Omega{ij} = \\int{D{ij}} \\cos \\beta d\\alpha d\\beta = 2 \\cos(\\betaj) \\sin \\left(\\frac{\\Delta \\beta}{2} \\right) \\Delta \\alpha, $ and D{ij} = [\\alphai-\\Delta \\alpha/2, \\alphai+\\Delta \\alpha/2] \\times [\\betaj - \\Delta \\beta / 2, \\betaj + \\Delta \\beta /2]$. We took a uniform grid such that  $ \\alphai = -s\\alpha/2+(i-1/2)\\Delta \\alpha \\  \\betaj = -s\\beta/2+(j-1/2)\\Delta \\beta \\\n\\Delta \\alpha = s\\alpha/N\\alpha \\\n\\Delta \\beta = s\\beta/N\\beta \\\n1 \\le i \\le N\\alpha \\  1 \\le j \\le N\\beta $. ","category":"page"},{"location":"initialization/pinholecamera/","page":"Pinhole camera","title":"Pinhole camera","text":"where s_alpha s_beta are the horizontal and vertical aperture angles respectively, and N_alpha, N_beta are the numbers of pixels. The total solid angle is Delta Omega = 2 sin(s_beta2)s_alpha","category":"page"},{"location":"spacetimes/autodiff/#Automatic-differentiation","page":"Automatic differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"spacetimes/autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"Unless a more specialized method is available, the Christoffel symbols for a given spacetime are calculated using forward-mode automatic differentiation from the metric coefficients, using functionality from the ForwardDiff package. ","category":"page"},{"location":"spacetimes/autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"Skylight.AutoDiffChristoffelCache","category":"page"},{"location":"spacetimes/autodiff/#Skylight.AutoDiffChristoffelCache","page":"Automatic differentiation","title":"Skylight.AutoDiffChristoffelCache","text":"AutoDiffChristoffelCache{F, CA, CO} <: AbstractChristoffelCache\n\nCache object for temporary storage in Christoffel symbol calculation via automatic differentiation. \n\nConstructor\n\nAutoDiffChristoffelCache(spacetime::AbstractSpacetime)\n\n\n\n\n\n","category":"type"},{"location":"#Skylight.jl","page":"Home","title":"Skylight.jl","text":"","category":"section"},{"location":"#Docs-under-construction...","page":"Home","title":"Docs under construction...","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Skylight.Skylight","category":"page"},{"location":"#Skylight.Skylight","page":"Home","title":"Skylight.Skylight","text":"Skylight.jl is an extensible package for general-relativistic ray tracing and radiative transfer in arbitrary spacetimes and radiative models.\n\n\n\n\n\n","category":"module"},{"location":"citing/#Citing","page":"Citing","title":"Citing","text":"","category":"section"}]
}
